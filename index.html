<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Web Terminal Emulator</title>
  <style>
    :root {
      --bg: #000;
      --fg: #fff;
      --cursor: #fff;
      --overlay: #5f5;
      --blue-bg: #005fef;
      --blue-pill: #000;
      --path-bg: #005fef;
      --path-fg: #fff;
    }
    body {
      background: #191919;
      color: var(--fg);
      font-family: monospace;
      margin: 0; padding: 0;
    }
    body.light-mode {
      background: #ffffff;
    }
    /* Website light mode - only affects website when no terminal theme is active */
    body.light-mode:not(.light-theme):not(.blue-theme):not(.dark-theme) {
      --bg: #fff;
      --fg: #000;
      --cursor: #000;
      --overlay: #080;
    }
    /* Dark terminal theme - explicit dark mode - highest specificity */
    body.dark-theme,
    body.light-mode.dark-theme {
      --bg: #000 !important;
      --fg: #fff !important;
      --cursor: #fff !important;
      --overlay: #5f5 !important;
    }
    body.light-theme {
      --bg: #fff;
      --fg: #000;
      --cursor: #000;
      --overlay: #080;
    }
    body.blue-theme .arrow1 {
      border-left-color: #000000;
    }
    body.blue-theme .arrow2 {
      border-left-color: #333;
    }
    body.blue-theme .arrow3 {
      border-left-color: #7e7d7d;
    }
    body.blue-theme {
      --bg: var(--blue-bg);    
      --fg: #fff;              
      --cursor: #fff;
      --overlay: #5f5;       
    }
    body.blue-theme .prompt-path,
    body.blue-theme .prompt-path::before,
    body.blue-theme .prompt-path::after {
      background: var(--blue-pill) !important;
      border-left-color: var(--blue-pill); 
    }
    .prompt-bar { 
      display: flex; 
      align-items: center; 
      margin-bottom: 8px; 
      position: relative;
      z-index: 10005;
    }
    .prompt-path { background: var(--path-bg, #005fef); color: var(--path-fg, #fff); padding: 4px 12px; font-weight: bold;
      clip-path: polygon(0 0, calc(100% - 10px) 0, 100% 50%, calc(100% - 10px) 100%, 0 100%);
      margin: 0 -12px 0 -10px; position: relative; display: inline-flex; align-items: center;
    }
    .prompt-path::before { content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 12px; background: var(--path-bg, #005fef); }
    .prompt-path::after { content: ''; position: absolute; right: -8px; top: 50%; transform: translateY(-50%);
      border-top: 8px solid transparent; border-bottom: 8px solid transparent; border-left: 8px solid var(--path-bg, #005fef);
    }
    .prompt-path {
      position: relative;
    }
    .prompt-path .path-seg,
    .prompt-path .path-slash {
      cursor: pointer;
      padding: 0;
    }
    .prompt-path .path-seg.active-prefix,
    .prompt-path .path-slash.active-prefix {
      background: var(--path-fg, #fff);
      color: var(--path-bg, #005fef);
    }
    body.blue-theme .prompt-path .path-seg.active-prefix,
    body.blue-theme .prompt-path .path-slash.active-prefix {
      color: #000; 
    }
    .history-arrows { display: inline-flex; align-items: center; margin-right: 8px; }
    .history-arrows span { width: 0; height: 0; border-top: 5px solid transparent; border-bottom: 5px solid transparent; margin-right: -2px; }
    .arrow1 { border-left: 6px solid #003fbb; }
    .arrow2 { border-left: 6px solid #005fe8; }
    .arrow3 { border-left: 6px solid #3399ff; }
    .input-wrapper { flex: 1; position: relative; z-index: 10005; }
    .prompt-input {
      width: 100%; background: transparent; border: none; margin: 0 8px; padding: 4px;
      text-indent: 1ch; font-family: monospace; font-size: 1em; outline: none; color: var(--fg); caret-color: transparent;
      position: relative; z-index: 10005;
    }
    .input-wrapper::after {
      content: '';
      position: absolute;
      top: 0;
      left: calc(var(--cursor-left, 0px) + 1ch);
      width: var(--cursor-width, 1ch);
      height: 100%; background: var(--cursor);
      animation: blink 0.5s step-end infinite;
      pointer-events: none; z-index: 1;
    }
    @keyframes blink { 50% { opacity: 0; } }
    .cmd-overlay { 
      position: absolute; 
      top: 4px; 
      pointer-events: none; 
      font-family: monospace; 
      white-space: pre; 
      z-index: 10006; 
      color: var(--overlay); 
      overflow: hidden; 
    }
    .suggestion { 
      position: absolute; 
      top: 4px; 
      pointer-events: none; 
      color: #888; 
      font-family: monospace; 
      font-size: 1em; 
      z-index: 10006;
    }
    .history-arg { white-space: pre; color: var(--fg); }
    .prompt-time {
      background: #444; color: #fff; padding: 4px 12px;
      clip-path: polygon(10px 0, 100% 0, 100% 100%, 10px 100%, 0 50%);
      margin: 0 -10px 0 -12px; position: relative;
    }
    .prompt-time::after { content: ''; position: absolute; left: -8px; top: 50%; transform: translateY(-50%);
      border-top: 8px solid transparent; border-bottom: 8px solid transparent; border-right: 8px solid #444; }
    .final-time { margin-left: auto; color: var(--fg); }
    .output-line { margin: 8px 0; color: var(--fg); }
    .fixed-footer {
      position: fixed;
      bottom: 0;
      left: 0;
      font-size: 0.75em;
      font-style: italic;
      color: #fff !important;             
      padding: 4px 8px;
    }
    .fixed-footer a {
      color: #005fef !important;           
      font-weight: bold;
      text-decoration: none;
    }
    .fixed-footer a:hover {
      background-color: #005fef !important;
      color: #fff !important;
      font-weight: bold;
      text-decoration: none;
      padding: 0 2px;
    }
    #help-modal {
      display: none;
      position: absolute;                 
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 36vw; max-height: 70vh;
      background: #f0f0f0;
      color: #333;
      border-radius: 0;
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
      overflow: hidden;
      z-index: 2500;                   
      font-family: Menlo, Monaco,"Courier New", monospace;
      resize: none;                    
    }
    #help-modal .modal-header {
      height: 28px;
      background: #e0e0e0;
      display: flex;
      align-items: center;
      padding: 0 8px;
      cursor: move;
    }
    #help-modal .modal-header .close-btn {
      width: 12px; height: 12px;
      background: #ff5f57;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: #000;
      line-height: 1;
    }
    #help-modal .modal-title {
      margin-left: 8px;
      margin: 0 auto;
      text-align: center;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-weight: 700;
      color: #000;
    }
    #help-modal .modal-search {
      width: calc(100% - 32px);
      display: block;
      padding: 6px 8px;
      box-sizing: border-box;
      font-size: 0.9em;
      border: 1px solid #ccc;
      margin: 8px auto;
    }
    #help-modal .modal-body {
      padding: 12px;
      overflow-y: auto;
      max-height: calc(70vh - 60px);
    }
    .cmd-item { border-bottom: 1px solid #ccc; }
    .cmd-header {
      padding: 8px; cursor: pointer;
      display: grid;
      grid-template-columns: auto 1fr auto;
      column-gap: 12px;
      align-items: center;
    }
    .toggle-arrow {
      font-size: 0.9em;
      transition: transform 0.3s ease-out;   
    }
    .toggle-arrow.open {
      transform: rotate(-180deg);
    }
    .cmd-detail {
      max-height: 0;                        
      overflow: hidden;             
      transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out; 
      background: #e8e8e8;                  
    }
    .cmd-detail.open {
      max-height: 500px;                    
      padding: 8px 16px;
    }
    .cmd-detail p, .cmd-detail ul { margin: 4px 0; }
    .cli-buttons {
      position: absolute;
      bottom: 16px;
      right: 16px;
      display: flex;
      gap: 8px;
      z-index: 10000;
    }
    /* Floating button group */
    .floating-button-group {
      position: fixed !important;
      bottom: 12px !important;
      right: 12px !important;
      display: flex;
      gap: 10px;
      z-index: 9999 !important;
      
      /* Panel styling */
      background: #191919;
      border: none;
      border-radius: 8px;
      padding: 8px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
      transition: box-shadow 0.2s ease, transform 0.2s ease;
    }

    .floating-button-group:hover {
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.2), 0 8px 32px rgba(0, 0, 0, 0.8);
      transform: translateY(-1px);
    }
    
    .floating-btn {
      width: 28px;
      height: 28px;
      background: transparent;
      color: #fff;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      transition: all 0.2s ease;
      font-family: monospace;
      font-weight: 700;
      padding: 0;
      position: relative;
    }
    
    .floating-btn:hover {
      transform: scale(1.1);
    }
    
    .floating-btn:active {
      transform: scale(0.95);
    }
    
    .floating-btn::after {
      content: attr(data-tip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      margin-bottom: 8px;
      font-weight: normal;
      backdrop-filter: blur(4px);
      max-width: 200px;
      text-align: center;
    }
    
    /* Special positioning for rightmost button tooltip */
    .cellular-automaton-btn::after {
      left: auto;
      right: 0;
      transform: none;
    }
    
    .floating-btn:hover::after {
      opacity: 1;
    }

    /* Theme toggle animations with language line */
    .theme-toggle-btn {
      position: relative;
    }
    
    .theme-toggle-btn .sun-icon,
    .theme-toggle-btn .moon-icon {
      position: absolute;
      transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    /* Dark mode shows SUN (indicating you can switch TO light mode) */
    .theme-toggle-btn .sun-icon {
      opacity: 1;
      transform: scale(1) rotate(0deg) translateY(0px);
    }
    
    .theme-toggle-btn .moon-icon {
      opacity: 0;
      transform: scale(0.5) rotate(-180deg) translateY(-10px);
    }
    
    /* Light mode shows MOON (indicating you can switch TO dark mode) */
    .theme-toggle-btn.light-mode .sun-icon {
      opacity: 0;
      transform: scale(0.5) rotate(180deg) translateY(10px);
    }
    
    .theme-toggle-btn.light-mode .moon-icon {
      opacity: 1;
      transform: scale(1) rotate(0deg) translateY(0px);
    }

    /* Terminal button animation */
    .terminal-toggle-btn svg {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .terminal-toggle-btn:hover svg {
      transform: translateX(2px);
    }
    
    .terminal-toggle-btn:active svg {
      transform: translateX(4px) scale(0.95);
    }

    /* Layout button animation */
    .layout-btn svg,
    .cellular-automaton-btn svg {
      transition: all 0.3s ease;
    }
    
    .layout-btn:hover svg,
    .cellular-automaton-btn:hover svg {
      transform: rotate(5deg);
    }
    
    .layout-btn:active svg,
    .cellular-automaton-btn:active svg {
      transform: rotate(-5deg) scale(0.95);
    }

    /* Active state glow for buttons - removed per user request */

    /* Light mode icon colors */
    body.light-mode .floating-btn {
      color: #000;
    }
    
    body.light-mode .floating-btn svg {
      color: #000;
    }
    
    body.light-mode .floating-btn::after {
      background: rgba(255, 255, 255, 0.9);
      color: #000;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    /* Light mode floating button group panel */
    body.light-mode .floating-button-group {
      background: #ffffff;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    }

    body.light-mode .floating-button-group:hover {
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1), 0 8px 32px rgba(0, 0, 0, 0.4);
      transform: translateY(-1px);
    }

    /* Cellular Automaton Menu */
    .ca-menu {
      position: fixed;
      bottom: 70px;
      right: 20px;
      width: 320px;
      background: rgba(20, 20, 20, 0.95);
      border: 1px solid #444;
      border-radius: 8px;
      padding: 8px;
      display: none;
      flex-direction: column;
      z-index: 1000;
      gap: 4px;
      z-index: 9999;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
    }

    body.light-mode .ca-menu {
      background: rgba(255, 255, 255, 0.95);
      border-color: #ccc;
      color: #000;
    }

    .ca-menu-section {
      margin-bottom: 6px;
    }

    .ca-menu-header {
      font-size: 12px;
      font-weight: bold;
      color: #aaa;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 4px 8px;
    }

    body.light-mode .ca-menu-header {
      color: #555;
    }

    .ca-count {
      font-size: 11px;
      color: #666;
      font-weight: normal;
    }

    body.light-mode .ca-count {
      color: #888;
    }

    .ca-info-icon {
      width: 14px;
      height: 14px;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.3s ease;
    }

    .ca-info-icon:hover {
      opacity: 1;
    }

    .ca-menu-item {
      padding: 6px 8px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 14px;
      background: transparent;
      border: none;
      position: relative;
    }

    .scope-icon {
      width: 10px;
      height: 10px;
      border: 1px solid #888;
      border-radius: 50%;
      position: relative;
      cursor: pointer;
      margin-right: 4px;
      flex-shrink: 0;
    }

    .scope-icon::before,
    .scope-icon::after {
      content: '';
      position: absolute;
      background: #888;
    }

    .scope-icon::before {
      width: 3px;
      height: 1px;
      top: 50%;
      left: -2px;
      transform: translateY(-50%);
      box-shadow: 11px 0 0 0 #888;
    }

    .scope-icon::after {
      width: 1px;
      height: 3px;
      left: 50%;
      top: -2px;
      transform: translateX(-50%);
      box-shadow: 0 11px 0 0 #888;
    }

    .scope-icon:hover {
      border-color: #00ff00;
    }

    .scope-icon:hover::before,
    .scope-icon:hover::after {
      background: #00ff00;
    }

    .scope-icon:hover::before {
      box-shadow: 11px 0 0 0 #00ff00;
    }

    .scope-icon:hover::after {
      box-shadow: 0 11px 0 0 #00ff00;
    }

    .scope-icon.active {
      border-color: #00ff00;
      box-shadow: 0 0 8px #00ff00;
    }

    .scope-icon.active::before,
    .scope-icon.active::after {
      background: #00ff00;
    }

    .scope-icon.active::before {
      box-shadow: 11px 0 0 0 #00ff00;
    }

    .scope-icon.active::after {
      box-shadow: 0 11px 0 0 #00ff00;
    }

    .ca-rename-btn {
      font-size: 18px;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .menu-item-content {
      display: flex;
      align-items: center;
      flex: 1;
      min-width: 0;
    }

    .menu-item-name {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-right: auto;
    }

    .automaton-id-popup {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      color: #00ff00;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      border: 1px solid #00ff00;
      z-index: 900;
      pointer-events: none;
      white-space: nowrap;
    }

    .ca-menu-item:hover {
      background: rgba(60, 60, 60, 0.6);
    }

    body.light-mode .ca-menu-item:hover {
      background: rgba(220, 220, 220, 0.6);
    }

    .ca-menu-item.launch-item {
      cursor: grab;
      border: 1px solid transparent;
      transition: all 0.3s ease;
    }

    .ca-menu-item.launch-item:hover {
      background: rgba(60, 60, 60, 0.6);
      border: 1px solid #555;
    }

    body.light-mode .ca-menu-item.launch-item:hover {
      background: rgba(220, 220, 220, 0.6);
      border: 1px solid #999;
    }

    .ca-menu-item.launch-item:active {
      cursor: grabbing;
    }

    .ca-menu-item.active {
      color: #66b3ff;
    }

    body.light-mode .ca-menu-item.active {
      color: #0066cc;
    }

    .ca-menu-item.highlighted {
      background: rgba(0, 255, 0, 0.2) !important;
      animation: highlight-flash 0.3s ease;
    }

    @keyframes highlight-flash {
      0%, 100% { background: rgba(0, 255, 0, 0.2); }
      50% { background: rgba(0, 255, 0, 0.4); }
    }

    @keyframes pixel-glow {
      0%, 100% {
        box-shadow: 0 0 8px #00ff00, 0 0 16px #00ff00;
      }
      50% {
        box-shadow: 0 0 12px #00ff00, 0 0 24px #00ff00;
      }
    }

    @keyframes gentle-flash {
      0%, 100% { background: rgba(60, 60, 60, 0.6); }
      50% { background: rgba(0, 255, 0, 0.3); }
    }

    body.light-mode .ca-menu-item.gentle-flash-light {
      animation: gentle-flash-light 1s ease-in-out infinite;
    }

    @keyframes gentle-flash-light {
      0%, 100% { background: rgba(220, 220, 220, 0.6); }
      50% { background: rgba(0, 255, 0, 0.3); }
    }

    .ca-menu-item.deactivate-all {
      color: #ff6b6b;
      font-weight: bold;
    }

    .ca-menu-item.deactivate-all:hover {
      background: rgba(139, 0, 0, 0.3);
    }

    .ca-menu-item.deactivate-all.disabled {
      opacity: 0.5;
      cursor: not-allowed;
      color: #666;
    }

    body.light-mode .ca-menu-item.deactivate-all.disabled {
      color: #999;
    }

    .ca-item-controls {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .ca-rename-btn {
      background: none;
      color: #aaa;
      border: none;
      border-radius: 3px;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 11px;
      transition: color 0.3s ease;
      opacity: 0.7;
    }

    .ca-rename-btn:hover {
      color: #fff;
      opacity: 1;
    }

    body.light-mode .ca-rename-btn {
      color: #666;
    }

    body.light-mode .ca-rename-btn:hover {
      color: #000;
    }

    .ca-delete-btn {
      background: #ff4444;
      color: white;
      border: none;
      border-radius: 3px;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
      transition: background 0.3s ease;
    }

    .ca-delete-btn:hover {
      background: #ff6666;
    }

    /* Drag and Drop */
    .ca-drag-seed {
      position: fixed;
      width: 20px;
      height: 20px;
      background: rgba(0, 95, 239, 0.8);
      border: 2px solid #005fef;
      border-radius: 50%;
      pointer-events: none;
      z-index: 10000;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px rgba(0, 95, 239, 0.6);
      animation: seed-pulse 1s ease-in-out infinite;
    }

    @keyframes seed-pulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.2); }
    }

    /* Hover tooltip for automata identification */
    .ca-hover-tooltip {
      position: fixed;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      z-index: 10001;
      transform: translate(-50%, -120%);
      white-space: nowrap;
      border: 1px solid #444;
    }

    body.light-mode .ca-hover-tooltip {
      background: rgba(255, 255, 255, 0.95);
      color: #000;
      border-color: #ccc;
    }

    /* Rename Modal */
    .ca-rename-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      background: rgba(20, 20, 20, 0.95);
      border: 1px solid #444;
      border-radius: 8px;
      padding: 16px;
      display: none;
      flex-direction: column;
      gap: 12px;
      z-index: 10002;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(15px);
    }

    body.light-mode .ca-rename-modal {
      background: rgba(255, 255, 255, 0.95);
      border-color: #ccc;
      color: #000;
    }

    .ca-rename-modal-header {
      font-size: 14px;
      font-weight: bold;
      color: #aaa;
      margin-bottom: 4px;
    }

    body.light-mode .ca-rename-modal-header {
      color: #555;
    }

    .ca-rename-modal-input {
      background: rgba(40, 40, 40, 0.9);
      border: 1px solid #555;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 14px;
      color: white;
      width: 100%;
      box-sizing: border-box;
    }

    body.light-mode .ca-rename-modal-input {
      background: rgba(255, 255, 255, 0.9);
      color: #000;
      border-color: #ccc;
    }

    .ca-rename-modal-input:focus {
      outline: none;
      border-color: #005fef;
    }

    body.light-mode .ca-rename-modal-input:focus {
      border-color: #0066cc;
    }

    .ca-rename-modal-buttons {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .ca-rename-modal-btn {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .ca-rename-modal-btn.save {
      background: #005fef;
      color: white;
    }

    .ca-rename-modal-btn.save:hover {
      background: #004dcf;
    }

    .ca-rename-modal-btn.cancel {
      background: rgba(60, 60, 60, 0.8);
      color: #ccc;
    }

    .ca-rename-modal-btn.cancel:hover {
      background: rgba(80, 80, 80, 0.9);
      color: white;
    }

    body.light-mode .ca-rename-modal-btn.cancel {
      background: rgba(220, 220, 220, 0.8);
      color: #666;
    }

    body.light-mode .ca-rename-modal-btn.cancel:hover {
      background: rgba(200, 200, 200, 0.9);
      color: #000;
    }

    /* Info Modal */
    .ca-info-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      max-width: 90vw;
      max-height: 80vh;
      background: rgba(30, 30, 30, 0.98);
      border: 1px solid #555;
      border-radius: 8px;
      padding: 20px;
      display: none;
      flex-direction: column;
      z-index: 10000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(15px);
      overflow: auto;
      min-width: 300px;
      min-height: 200px;
      cursor: move;
      user-select: none;
    }

    body.light-mode .ca-info-modal {
      background: rgba(255, 255, 255, 0.98);
      border-color: #ccc;
      color: #000;
    }

    .ca-info-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      user-select: none;
      padding: 8px;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.05);
    }

    .ca-info-modal-header:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    body.light-mode .ca-info-modal-header {
      background: rgba(0, 0, 0, 0.03);
    }

    body.light-mode .ca-info-modal-header:hover {
      background: rgba(0, 0, 0, 0.05);
    }

    .ca-info-modal-title {
      font-size: 18px;
      font-weight: bold;
      display: flex;
      flex-direction: column;
    }

    .drag-hint {
      font-size: 11px;
      font-weight: normal;
      opacity: 0.6;
      margin-top: 2px;
      font-style: italic;
    }

    .ca-info-modal-close {
      background: #ff4444;
      color: white;
      border: none;
      border-radius: 50%;
      width: 25px;
      height: 25px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
    }

    .ca-info-modal-close:hover {
      background: #ff6666;
    }

    .ca-info-modal-content {
      overflow-y: auto;
      flex: 1;
    }

    .ca-info-modal-content h3 {
      color: #005fef;
      margin-top: 20px;
      margin-bottom: 10px;
    }

    body.light-mode .ca-info-modal-content h3 {
      color: #0040a0;
    }

    .ca-info-modal-content p {
      line-height: 1.6;
      margin-bottom: 12px;
    }

    .ca-info-modal-content a {
      color: #66b3ff;
      text-decoration: none;
    }

    .ca-info-modal-content a:hover {
      text-decoration: underline;
    }

    body.light-mode .ca-info-modal-content a {
      color: #0066cc;
    }

    .ca-automaton-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin: 15px 0;
    }

    .ca-automaton-card {
      background: rgba(40, 40, 40, 0.6);
      border: 1px solid #555;
      border-radius: 6px;
      padding: 12px;
    }

    body.light-mode .ca-automaton-card {
      background: rgba(240, 240, 240, 0.6);
      border-color: #ccc;
    }

    .ca-automaton-card h4 {
      color: #005fef;
      margin-bottom: 8px;
    }

    body.light-mode .ca-automaton-card h4 {
      color: #0040a0;
    }

    /* Light mode styles */
    body.light-mode {
      background: #ffffff;
      color: #000000;
    }
    
    body.light-mode .fixed-footer {
      color: #000000 !important;
    }
    
    body.light-mode .fixed-footer a {
      color: #0066cc !important;
    }

    /* Cellular Automaton Styles */
    .ca-pixel {
      position: fixed;
      width: 6px;
      height: 6px;
      pointer-events: none;
      z-index: 800;
      cursor: default;
      transition: all 0.2s ease;
      border-radius: 1px;
    }
    
    .ca-pixel.blue {
      background-color: #005fef;
      box-shadow: 0 0 2px rgba(0, 95, 239, 0.4);
    }
    
    .ca-pixel.white {
      background-color: #ffffff;
      box-shadow: 0 0 2px rgba(255, 255, 255, 0.4);
    }
    
    /* Light mode: white pixels become black */
    body.light-mode .ca-pixel.white {
      background-color: #000000;
      box-shadow: 0 0 2px rgba(0, 0, 0, 0.4);
    }
    
    .ca-pixel.cursor-hover {
      transform: scale(1.2);
      filter: brightness(1.3);
      z-index: 810;
    }
    
    .ca-pixel.destroying {
      animation: pixelDestroy 0.6s ease-out forwards;
    }
    
    @keyframes pixelDestroy {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      25% {
        transform: scale(1.5) rotate(90deg);
        opacity: 0.8;
      }
      50% {
        transform: scale(0.3) rotate(180deg);
        opacity: 0.6;
      }
      75% {
        transform: scale(1.8) rotate(270deg);
        opacity: 0.3;
      }
      100% {
        transform: scale(0) rotate(360deg);
        opacity: 0;
      }
    }
    
    .ca-pixel.highlight {
      box-shadow: 0 0 8px #00ff00, 0 0 16px #00ff00;
      filter: brightness(1.5);
      z-index: 810;
    }

    /* Legacy terminal button styles - now uses floating-btn */
    .btn {
      background: linear-gradient(135deg, #666 0%, #555 50%, #444 100%);
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-weight: 700;
      border: none;
      padding: 0px 8px;
      line-height: 1.1;
      border-radius: 3px;
      cursor: pointer;
      transition: transform 0.1s ease, background 0.2s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.1);
      position: relative;
    }
    .btn::before {
      content: '';
      position: absolute;
      top: 1px;
      left: 1px;
      right: 1px;
      height: 40%;
      background: linear-gradient(180deg, rgba(255,255,255,0.12) 0%, rgba(255,255,255,0.04) 100%);
      border-radius: 2px 2px 0 0;
      pointer-events: none;
    }
    .btn:hover {
      background: linear-gradient(135deg, #777 0%, #666 50%, #555 100%);
      box-shadow: 0 3px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.15);
    }
    .btn:active {
      transform: scale(0.95);
    }
    .theme-btn {
      width: 28px;
      height: 28px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .theme-indicator {
      display: block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #fff; 
    }
    #terminal-window {
      position: fixed;
      top: 35vh;
      left: 5vw;
      width: 33.75vw;              
      height: 35vh;
      min-height: 120px;
      max-height: calc(100vh - 35vh - 80px);
      background: var(--bg);
      border: 1px solid #444;
      box-shadow: 0 8px 24px rgba(0,0,0,0.5);
      display: none;
      flex-direction: column;
      resize: none;
      overflow: hidden;
      z-index: 1500;
      transition: opacity 0.3s ease, transform 0.3s ease;
      will-change: transform;
      transform: translateZ(0); /* Force hardware acceleration */
    }
    #terminal-window.show {
      animation: terminalFadeIn 0.3s ease-out forwards;
    }
    #terminal-window.hide {
      animation: terminalFadeOut 0.25s ease-in forwards;
    }
    @keyframes terminalFadeIn {
      0% {
        opacity: 0;
        transform: scale(0.9) translateY(10px);
      }
      100% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }
    @keyframes terminalFadeOut {
      0% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
      100% {
        opacity: 0;
        transform: scale(0.95) translateY(-5px);
      }
    }
    #screen-outline {
      position: absolute;
      top: 7vh;
      left: 4vw;
      width: 33.75vw;   
      height: 25vh;
      max-height: calc(100vh - 7vh - 80px);
      border: 2px solid var(--light-grey);
      box-sizing: border-box;
      pointer-events: none;
      z-index: 100;   
    }
    #terminal {
      flex: 1;
      padding: 10px;
      padding-bottom: 50px;
      overflow-y: auto;
      box-sizing: border-box;
      height: auto;
      display: flex;
      flex-direction: column;
      min-height: 80px;
      color: var(--fg);
    }
    :root {
      --light-grey: #d9d9d9;
    }
    #keyboard{
      position: fixed;
      left: 5vw;
      bottom: 3vh;
      width: 33.75vw;
      z-index: 1400;
      display: grid;
      grid-template-columns: repeat(17, 1fr);
      grid-auto-rows: 3em;
      --gap: .32em;                
      gap: var(--gap);
      justify-content: center;
    }
    #keyboard .key{
      display:flex;
      flex-direction:column;
      justify-content:flex-end;         
      align-items:center;
      border:2px solid var(--light-grey);
      box-sizing:border-box;
      color:var(--light-grey);
      font-family: Menlo, monospace;
      user-select:none;
      text-transform: lowercase;
      border-radius: 8px;
      position: relative;            
      padding-bottom:12px;            
      font-size:0.82em;                
    }
    .key[data-alt]::before{
      content: attr(data-alt);
      position:absolute;
      top: 6px;                 
      left:50%;
      transform:translateX(-50%);
      font-size:0.48em;
      line-height:1;
      opacity:0.9;
    }
    #keyboard .key[data-alt]{
      padding-top:14px !important;   
      padding-bottom:4px !important; 
      font-size:0.80em !important;
      justify-content:flex-end !important;
    }
    #keyboard .key.quote[data-alt]{
      padding-top:18px !important;   
      padding-bottom:2px !important;
    }
    #keyboard .key.quote[data-alt]::before{
      top:6px !important;            
    }
    #keyboard .key.comma[data-alt],
    #keyboard .key.dot[data-alt] {
      padding-top: 11px !important;
      padding-bottom: 3px !important;
    }
    #keyboard .key:not([data-alt]):not(.long){
      justify-content: center !important;
      padding: 0 !important;
      font-size: 0.88em !important;
    }
    .lbr[data-alt]::before,
    .rbr[data-alt]::before,
    .bslash[data-alt]::before,
    .semi[data-alt]::before,
    .quote[data-alt]::before,
    .comma[data-alt]::before,
    .dot[data-alt]::before,
    .slash[data-alt]::before{
      top: 6px;
      font-size: 0.48em;
    }
    #keyboard .key.long{
      grid-column: auto;
      border: none !important;
      position: relative;
      margin: 0;                        
      padding: 0;                        
      display: flex;
      align-items: center !important;
      justify-content: center !important;
    }
    #keyboard .key.long::after{
      content:"";
      position:absolute;
      top:0; bottom:0;
      left: calc(var(--gap)/2);          
      right: calc(var(--gap)/2);
      border:2px solid var(--light-grey);
      border-radius:8px;
      box-sizing:border-box;
      pointer-events:none;
    }
    #keyboard .key.enter.long::after,
    #keyboard .key.shift-l.long::after,
    #keyboard .key.shift-r.long::after{
      left: calc(var(--gap)/3);
      right: calc(var(--gap)/3);
    }
    #keyboard .key.semi[data-alt],
    #keyboard .key.quote[data-alt]{
      padding-left: .25em !important;
      padding-right:.25em !important;
    }
    #keyboard .key.semi{ transform: translateX(1px); }
    .spacebar{
      grid-row: 5;
      grid-column: 4 / 13;             
      height: 2.6em;
      line-height: 2.6em;
      transform: translateX(calc(var(--step) * 2.2));   
    }
    #keyboard > .key:nth-child(-n+14){ grid-row: 1; }
    #keyboard > .key:nth-child(n+15):nth-child(-n+28){ grid-row: 2; }
    #keyboard > .key:nth-child(n+29):nth-child(-n+41){ grid-row: 3; }
    #keyboard > .key:nth-child(n+42):nth-child(-n+53){ grid-row: 4; }
    #keyboard > .key:nth-child(54){ grid-row: 5; }
    :root{
      --key: 3em;
      --gap: 0.25em;
      --step: calc((var(--key) + var(--gap)) / 2); 
    }
    #keyboard > .key:nth-child(n+15):nth-child(-n+28){
      transform: translateX(calc(var(--step) * 0.9));
    }
    #keyboard > .key:nth-child(n+29):nth-child(-n+41){
      transform: translateX(calc(var(--step) * 2.0));
    }
    #keyboard > .key:nth-child(n+42):nth-child(-n+53){
      transform: translateX(calc(var(--step) * 3.1));
    }
    #keyboard .key.active {
      background: #005fef;
      color: #000;
    }
    #keyboard .key.long.pressed,
    #keyboard .key.long.active{
      background:none !important;
    }
    #keyboard .key.long.pressed::after,
    #keyboard .key.long.active::after{
      background: var(--accent, #147bff);  
    }
    /* C) trim the right edge: last column is only 0.4u */
#keyboard {
  grid-template-columns: repeat(14, var(--key)) calc(0.4 * var(--key)) !important;
}

    #keyboard > .key:nth-child(n+29):nth-child(-n+41),
    #keyboard > .key:nth-child(n+42):nth-child(-n+53) { transform: none !important; }
    #keyboard .spacebar { transform: none !important; }
    #keyboard .key.long        { grid-column: span 2; }   
    #keyboard .esc.long        { grid-column: span 1; }

#keyboard .tab.long {
  grid-column-start: 1 !important;   /* same as Esc */
  grid-column-end: 2 !important;     /* take only the first slot */
  width: calc(1.5 * var(--key) + var(--gap));
  justify-content: flex-start;
  padding-left: 0.5em;
  margin-left: 0 !important;
}

/* Shift the Q row (row 2) by half a key width */
#keyboard > .key:nth-child(n+15):nth-child(-n+28) {
  transform: translateX(calc(0.5 * var(--key) + 0.5 * var(--gap)));
}

/* TAB: stay in column 1, cancel the row's stagger, keep 1.5u visual width */
#keyboard .tab.long{
  grid-column: 1 / 2 !important;        /* Q stays where it is */
  transform: none !important;           /* undo the row's translateX on TAB */
  width: calc(1.5 * var(--key) + var(--gap));
}

/* Let the default long-key outline handle spacing; no custom width/left */
#keyboard .tab.long::after{
  left: calc(var(--gap)/2);
  right: calc(var(--gap)/2);
  width: auto;
}

/* Center the TAB label inside the key */
#keyboard .tab.long{
  justify-content: center !important;
  align-items: center !important;  /* vertical center, to match other long keys */
  padding-left: 0 !important;
}

/* Shrink DEL so its right edge aligns with the "\" key below */
#keyboard .back.long{
  grid-column: span 2;                               /* keep it in the last two tracks */
  width: calc(1.4 * var(--key) + var(--gap));        /* 1.5u visual width */
  justify-self: start;                                /* stick to the left, next to "=" */
}

#keyboard .back.long::after{
  left: calc(var(--gap)/2);                           /* normal left inset */
  right: auto;                                        /* don't stretch to the end */
  width: 100%;                                        /* match the shrunk width */
}

/* Shrink ENTER so its right edge lines up with "\" and DEL */
#keyboard .enter.long{
  grid-column: span 2;                             /* keep its grid span */
  width: calc(1.4 * var(--key) + var(--gap));      /* same width as DEL */
  justify-self: start;                              /* anchor to the left */
}

#keyboard .enter.long::after{
  left: calc(var(--gap)/2);                         /* normal inset */
  right: auto;                                      /* don't stretch to the end */
  width: 100%;                                      /* match the shrunk width */
}



    #keyboard .caps.long       { grid-column: span 2; }
    #keyboard .enter.long      { grid-column: span 2; } 
    #keyboard .shift-l.long    { grid-column: span 2; }
    #keyboard .shift-r.long    { grid-column: span 3; }   
    #keyboard .back.long       { grid-column: span 2; }   
    

    #help-modal      { border-radius: 12px !important; }
    #terminal-window { border-radius: 12px; overflow: hidden; }

   /* --- Bottom row layout tweaks --- */

/* 1) Push Z…/ half a key to the right (so Z centers under A) */
#keyboard > .key:nth-child(n+43):nth-child(-n+52) {
  transform: translateX(var(--step)) !important; /* step = 0.5 key + 0.5 gap */
}

/* 2) Lengthen LEFT SHIFT to fill that half-key gap */
#keyboard .shift-l.long {
  padding-right: var(--step) !important;
}
#keyboard .shift-l.long::after {
  right: calc(var(--gap)/3 - var(--step)) !important; /* extend the outline */
}

/* 3) Shorten RIGHT SHIFT and align its right edge with ENTER */
#keyboard .shift-r.long {
  grid-column: span 2 !important;                        /* same tracks as ENTER */
  width: calc(1.4 * var(--key) + var(--gap)) !important; /* same visual width */
  justify-self: start !important;

  /* NEW: move it right so it clears the "/ ? " key */
  margin-left: var(--step) !important;
}
#keyboard .shift-r.long::after {
  left: calc(var(--gap)/2) !important;
  right: auto !important;
  width: 100% !important;
}

/* Right SHIFT — align with the stagger AND reach the keyboard edge */
#keyboard .shift-r.long{
  grid-column: span 2 !important;        /* same two tracks as enter */
  justify-self: stretch !important;       /* fill its grid area */
  width: auto !important;                  /* let stretch work */
  margin-left: var(--step) !important;     /* clears the moved "/ ? " key */
}

/* Extend the drawn outline to close the half-key gap on the right */
#keyboard .shift-r.long::after{
  left:  calc(var(--gap)/2) !important;
  right: calc(var(--gap)/3 - var(--step)) !important; /* negative = extend out */
  width: auto !important;
}

/* Use row flex so we can insert a horizontal spacer */
#keyboard .key.long{
  flex-direction: row !important;
}

/* Don't pad the left shift; we extend only with the outline */
#keyboard .shift-l.long{ padding-right: 0 !important; }

/* How far the outline extends past the element on each shift key */
#keyboard .shift-l.long,
#keyboard .shift-r.long{
  --extend: calc(var(--step) - var(--gap)/3);
}

/* Insert a left spacer equal to half the extension so text is centered
   relative to the drawn outline (works for both shifts). */
#keyboard .shift-l.long::before,
#keyboard .shift-r.long::before{
  content: "";
  display: block;
  width: calc(var(--extend) / 2);
  height: 1px; /* just to create a flex item */
}

/* optional micro-tune */
#keyboard .shift-l.long::before,
#keyboard .shift-r.long::before{ width: calc(var(--extend) / 2 + 1em); }

/* --- FIX: make the spacebar shorter --- */
#keyboard .key.spacebar{
  grid-row: 5;                         /* keep it on the bottom row */
  grid-column: 3 / 14 !important;      /* adjust these numbers to taste */
  height: 3em;
  line-height: 3em;
  margin: 0 !important;
  transform: none !important;
}

/* --- Keyboard Panel --- */
#keyboard-panel{
  position: fixed;
  left: 5vw;
  bottom: 3vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #444;
  border: 1px solid #444;
  border-radius: 8px;
  padding: 10px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.35);
  z-index: 1450;
  overflow: hidden;
  box-sizing: border-box;
  transition: opacity 0.3s ease, transform 0.3s ease;
}

#keyboard-panel.hidden {
  opacity: 0;
  transform: translateY(20px);
  pointer-events: none;
}


/* drag handle */
#keyboard-panel .panel-header{
  display: none !important;
  height: 0 !important;
  margin: 0 !important;
  padding: 0 !important;
}


/* make the grid live inside the panel (stop being fixed) */
#keyboard{
  position: static !important;
  left: auto !important;
  bottom: auto !important;
  width: auto !important;
  transform-origin: center center;
  margin: 0 auto;
  display: grid !important;
}


/* enhance keyboard key outlines on panel */
#keyboard .key,
#keyboard .key.long::after{
  border-color: #bfbfbf;
}

/* Make icon buttons compact and keep icons white via currentColor */
.icon-btn{
  width: 28px;
  height: 28px;
  padding: 0;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  color: #fff;               /* icons white */
}
.icon-btn .icon{
  width: 16px;
  height: 16px;
  display: block;
  fill: currentColor;
  stroke: currentColor;
  stroke-width: 0;
}

/* Bigger lone question mark */
.help-btn .icon{
  width: 18px;
  height: 18px;
}

/* Keyboard button is wider; keep height the same */
.keyboard-toggle-btn{
  width: 40px;
}
.keyboard-toggle-btn .icon{
  width: 30px;
  height: 27px;
}

/* Larger eraser icon so it fills the button */
.clear-btn .icon{
  width: 22px;
  height: 22px;
}


/* Utility to hide elements with animation - removed display:none to allow transitions */
.hidden { 
  opacity: 0 !important; 
  pointer-events: none !important;
  transform: translateY(20px) !important;
}

/* Keyboard keys: filled black, white labels; invert on press; long keys fill with ::after */
#keyboard .key{
  background: #000 !important;
  color: #fff !important;
  border: 0 !important;
  position: relative;
  z-index: 0;
}
#keyboard .key::before{ color: inherit !important; }
#keyboard .key.long::after{
  background: #000 !important;
  border: 0 !important;
  z-index: -1 !important;
}
#keyboard .key.active,
#keyboard .key.pressed{
  background: #fff !important;
  color: #000 !important;
}
#keyboard .key.long.active::after,
#keyboard .key.long.pressed::after{
  background: #fff !important;
  border: 0 !important;
}
#keyboard .key.long.active,
#keyboard .key.long.pressed{ background: transparent !important; }

/* ---- tiny label tooltips for CLI buttons ---- */
.cli-buttons .btn{ position:relative; }
.cli-buttons .btn[data-tip]::after{
  content: attr(data-tip);
  position: absolute;
  top: -26px;           /* show above the button */
  right: 0;
  background: #333;
  color: #fff;
  font: 600 11px/1 -apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  padding: 4px 6px;
  border-radius: 4px;
  pointer-events: none;
  white-space: nowrap;
  opacity: 0;
  transform: translateY(4px);
  transition: opacity .15s ease, transform .15s ease;
  box-shadow: 0 4px 10px rgba(0,0,0,.3);
}
.cli-buttons .btn:hover[data-tip]::after{
  opacity: 1;
  transform: translateY(0);
}
/* allow horizontal overflow with a bottom scrollbar */
#terminal {
  overflow-x: auto;
}

/* keep hover lit up like active */
#keyboard .key:hover {
  background: #fff !important;
  color: #000 !important;
}
#keyboard .key.long:hover::after {
  background: #fff !important;
}

/* --- Vim Editor Modal --- */
#vim-editor {
  display: none;
  position: fixed;
  top: 20vh;
  left: 25vw;
  width: 50vw;
  height: 40vh;
  background: #2d1b69;
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.6);
  overflow: hidden;
  z-index: 2600;
  font-family: 'Courier New', monospace;
}

#vim-editor .vim-header {
  height: 30px;
  background: #1a0f40;
  display: flex;
  align-items: center;
  padding: 0 12px;
  border-bottom: 1px solid #4a3085;
  color: #e0e0e0;
}

#vim-editor .vim-close {
  width: 12px;
  height: 12px;
  background: #ff5f57;
  border-radius: 50%;
  cursor: pointer;
  margin-right: 8px;
}

#vim-editor .vim-filename {
  flex: 1;
  text-align: center;
  font-weight: bold;
  font-size: 13px;
}

#vim-editor .vim-body {
  display: flex;
  height: calc(100% - 30px);
}

#vim-editor .vim-sidebar {
  width: 200px;
  min-width: 150px;
  max-width: 400px;
  background: #241456;
  border-right: 1px solid #4a3085;
  padding: 8px;
  position: relative;
  flex-shrink: 0;
}

#vim-editor .vim-sidebar .resize-handle {
  position: absolute;
  top: 0;
  right: 0;
  width: 4px;
  height: 100%;
  background: transparent;
  cursor: col-resize;
  z-index: 10;
}

#vim-editor .vim-sidebar .resize-handle:hover {
  background: #4a3085;
}

#vim-editor .vim-sidebar h4 {
  color: #c9b3ff;
  font-size: 12px;
  margin: 0 0 8px 0;
  text-transform: uppercase;
}

#vim-editor .vim-file-tree {
  color: #a0a0a0;
  font-size: 12px;
}

#vim-editor .vim-file-tree .file-item {
  padding: 2px 0;
  cursor: pointer;
}

#vim-editor .vim-file-tree .file-item:hover {
  color: #c9b3ff;
}

#vim-editor .vim-main {
  flex: 1;
  display: flex;
  flex-direction: column;
}

#vim-editor .vim-tabs {
  height: 28px;
  background: #1a0f40;
  border-bottom: 1px solid #4a3085;
  display: flex;
  align-items: center;
  padding: 0 8px;
}

#vim-editor .vim-tab {
  background: #2d1b69;
  color: #e0e0e0;
  padding: 4px 12px;
  border-radius: 4px 4px 0 0;
  font-size: 12px;
  margin-right: 4px;
}

#vim-editor .vim-content {
  flex: 1;
  position: relative;
  display: flex;
  flex-direction: column;
}

#vim-editor .vim-textarea {
  width: 100%;
  flex: 1;
  background: #2d1b69;
  color: #e0e0e0;
  border: none;
  outline: none;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'DejaVu Sans Mono', monospace;
  font-size: 14px;
  padding: 12px;
  resize: none;
  line-height: 1.4;
}

#vim-editor .vim-message-overlay {
  position: absolute;
  bottom: 12px;
  left: 12px;
  right: 12px;
  background: rgba(26, 15, 64, 0.95);
  color: #ffffff;
  padding: 8px 12px;
  border-radius: 4px;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'DejaVu Sans Mono', monospace;
  font-size: 12px;
  border: 1px solid #4a3085;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  opacity: 0;
  transform: translateY(10px);
  transition: opacity 0.2s ease, transform 0.2s ease;
  pointer-events: none;
  z-index: 10;
}

#vim-editor .vim-message-overlay.show {
  opacity: 1;
  transform: translateY(0);
}

#vim-editor .vim-status {
  height: 32px;
  background: #1a0f40;
  border-top: 1px solid #4a3085;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 12px;
  font-size: 12px;
  color: #a0a0a0;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'DejaVu Sans Mono', monospace;
  flex-shrink: 0;
}

#vim-editor .vim-mode {
  background: #4a3085;
  color: #ffffff;
  font-weight: bold;
  padding: 6px 12px;
  border-radius: 4px;
  min-width: 100px;
  text-align: center;
  font-size: 12px;
  letter-spacing: 0.5px;
  border: 1px solid #6a5085;
}

    /* Website Content Styles */
    .website-menu {
      position: static;
      height: 60px;
      background: rgba(25, 25, 25, 0.95);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50; /* Below terminal and automata */
      font-family: monospace;
      padding-top: 10px; /* Lower the text */
    }

    body.light-mode .website-menu {
      background: rgba(255, 255, 255, 0.95);
    }

    .website-menu-container {
      width: 50%;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .website-menu-left {
      display: flex;
      align-items: center;
      gap: 40px;
    }

    .website-menu-brand {
      font-size: 18px;
      font-weight: bold;
      color: #005fef;
      text-decoration: none;
      cursor: pointer;
      padding: 0px 1px;
      transition: all 0.3s ease;
    }

    .website-menu-brand:hover {
      color: #191919;
      background: white;
    }

    body.light-mode .website-menu-brand:hover {
      color: white;
      background: #191919;
    }

    .website-menu-nav {
      display: flex;
      gap: 30px;
    }

    .website-menu-nav a {
      color: white;
      text-decoration: none;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      padding: 0px 1px;
      transition: all 0.3s ease;
    }

    .website-menu-nav a:hover {
      color: #191919;
      background: white;
    }

    body.light-mode .website-menu-nav a {
      color: #191919;
    }

    body.light-mode .website-menu-nav a:hover {
      color: white;
      background: #191919;
    }

    .website-menu-icons {
      display: flex;
      gap: 20px;
    }

    .website-menu-icons a {
      color: inherit;
      text-decoration: none;
    }

    .website-menu-icon {
      width: 18px;
      height: 18px;
      cursor: pointer;
      transition: opacity 0.3s ease;
      color: white;
    }

    body.light-mode .website-menu-icon {
      color: #191919;
    }

    .website-menu-icon:hover {
      opacity: 0.7;
    }

    /* Scroll to top button */
    .scroll-to-top {
      position: fixed;
      bottom: 30px;
      left: 30px;
      width: 50px;
      height: 50px;
      background: rgba(25, 25, 25, 0.9);
      border: 1px solid #333;
      border-radius: 50%;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }

    body.light-mode .scroll-to-top {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ddd;
    }

    .scroll-to-top:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    body.light-mode .scroll-to-top:hover {
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    .scroll-to-top svg {
      width: 24px;
      height: 24px;
      fill: #fff;
    }

    body.light-mode .scroll-to-top svg {
      fill: #191919;
    }

    .website-content {
      position: relative;
      z-index: 10; /* Below everything else */
      display: flex;
      justify-content: center;
      min-height: 100vh;
    }

    .website-content-container {
      width: 50%;
      padding: 40px 0;
      opacity: 1;
      transition: opacity 0.5s ease;
    }

    .website-content-container.fade-out {
      opacity: 0;
    }

    .website-page {
      display: none;
      font-family: monospace;
      line-height: 1.6;
    }

    .website-page.active {
      display: block;
    }

    .website-page p {
      color: white;
      font-size: 14px;
      margin-bottom: 20px;
    }

    body.light-mode .website-page p {
      color: #191919;
    }

    /* Technical Skills Styles */
    .skills-section {
      margin-bottom: 25px;
    }

    .skills-section h3 {
      color: white;
      font-size: 16px;
      margin-bottom: 12px;
      padding-bottom: 0;
      border: none;
    }

    body.light-mode .skills-section h3 {
      color: #191919;
    }

    .skills-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 15px;
    }

    .skill-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.05);
      transition: all 0.3s ease;
      cursor: default;
      font-size: 13px;
    }

    body.light-mode .skill-item {
      border: 1px solid rgba(0, 0, 0, 0.2);
      background: rgba(0, 0, 0, 0.05);
    }

    .skill-item:hover {
      transform: scale(1.05);
      border-color: rgba(255, 255, 255, 0.4);
      background: rgba(255, 255, 255, 0.1);
      box-shadow: 0 2px 8px rgba(0, 95, 239, 0.3);
    }

    body.light-mode .skill-item:hover {
      border-color: rgba(0, 0, 0, 0.4);
      background: rgba(0, 0, 0, 0.1);
      box-shadow: 0 2px 8px rgba(0, 61, 153, 0.3);
    }

    .skill-icon {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .skill-name {
      font-weight: 500;
      white-space: nowrap;
      color: white;
    }

    body.light-mode .skill-name {
      color: #191919;
    }

    .research-project {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 30px;
      transition: all 0.3s ease;
    }

    .research-project:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    body.light-mode .research-project {
      background: rgba(0, 0, 0, 0.03);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    body.light-mode .research-project:hover {
      background: rgba(0, 0, 0, 0.06);
      border-color: rgba(0, 0, 0, 0.2);
    }

    .research-project h3 {
      margin-top: 0;
      margin-bottom: 15px;
      color: #fff;
    }

    body.light-mode .research-project h3 {
      color: #191919;
    }

    .github-link {
      color: #fff;
      font-weight: bold;
      font-style: normal;
      text-decoration: none;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 6px;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      vertical-align: middle;
    }

    .github-link svg {
      margin-right: 6px;
      flex-shrink: 0;
      vertical-align: middle;
    }

    .github-link:hover {
      background-color: #fff;
      color: #191919;
    }

    body.light-mode .github-link {
      color: #666;
    }

    body.light-mode .github-link:hover {
      background-color: #191919;
      color: #fff;
    }

    .website-link {
      color: #005fef;
      font-weight: bold;
      text-decoration: none;
      cursor: pointer;
      padding: 0px 1px;
      transition: all 0.3s ease;
    }

    .website-link:hover {
      color: #191919;
      background: white;
    }

    body.light-mode .website-link:hover {
      color: white;
      background: #191919;
    }

    .terminal-link, .automata-link {
      position: relative;
    }

    /* Industry Experience Styles */
    .industry-experience-container {
      display: flex;
      align-items: flex-start;
      gap: 25px;
      margin-bottom: 30px;
    }

    .industry-logo {
      width: 100px;
      height: 100px;
      border-radius: 8px;
      object-fit: cover;
      flex-shrink: 0;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    body.light-mode .industry-logo {
      border: 1px solid rgba(0, 0, 0, 0.2);
    }

    .industry-experience {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 20px;
      transition: all 0.3s ease;
      flex: 1;
    }

    .industry-experience:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    body.light-mode .industry-experience {
      background: rgba(0, 0, 0, 0.03);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    body.light-mode .industry-experience:hover {
      background: rgba(0, 0, 0, 0.06);
      border-color: rgba(0, 0, 0, 0.2);
    }

    .industry-content {
      flex: 1;
    }

    .industry-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 8px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .industry-org {
      font-size: 1.3em;
      font-weight: bold;
      color: #fff;
      margin: 0;
    }

    body.light-mode .industry-org {
      color: #191919;
    }

    .industry-location-date {
      color: #ccc;
      font-size: 0.9em;
      font-style: italic;
    }

    body.light-mode .industry-location-date {
      color: #666;
    }

    .industry-title {
      color: #fff;
      font-weight: bold;
      margin-bottom: 5px;
    }

    body.light-mode .industry-title {
      color: #191919;
    }

    .industry-technologies {
      color: #ccc;
      font-style: italic;
      font-size: 0.95em;
      margin-bottom: 15px;
    }

    body.light-mode .industry-technologies {
      color: #666;
    }

    .industry-description {
      color: #ddd;
      line-height: 1.6;
      font-size: 0.9em;
    }

    body.light-mode .industry-description {
      color: #444;
    }

    /* Project Styles */
    .project-container {
      display: flex;
      align-items: flex-start;
      gap: 25px;
      margin-bottom: 30px;
    }

    .project-logo {
      width: 100px;
      height: 100px;
      border-radius: 8px;
      object-fit: cover;
      flex-shrink: 0;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    body.light-mode .project-logo {
      border: 1px solid rgba(0, 0, 0, 0.2);
    }

    .project {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 20px;
      transition: all 0.3s ease;
      flex: 1;
    }

    .project:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    body.light-mode .project {
      background: rgba(0, 0, 0, 0.03);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    body.light-mode .project:hover {
      background: rgba(0, 0, 0, 0.06);
      border-color: rgba(0, 0, 0, 0.2);
    }

    .project h3 {
      margin-top: 0;
      margin-bottom: 15px;
      color: #fff;
    }

    body.light-mode .project h3 {
      color: #191919;
    }

    /* WildWhere specific layout */
    .wildwhere-logo {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 0 auto 20px auto;
    }

    .wildwhere-project {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 20px;
      transition: all 0.3s ease;
      width: 100%;
      margin-bottom: 30px;
    }

    .wildwhere-project:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.2);
    }

    body.light-mode .wildwhere-project {
      background: rgba(0, 0, 0, 0.03);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    body.light-mode .wildwhere-project:hover {
      background: rgba(0, 0, 0, 0.06);
      border-color: rgba(0, 0, 0, 0.2);
    }

    .wildwhere-project h3 {
      margin-top: 0;
      margin-bottom: 15px;
      color: #fff;
    }

    body.light-mode .wildwhere-project h3 {
      color: #191919;
    }


  </style>
</head>
<body class="light-mode dark-theme">

<!-- Website Content -->
<div class="website-menu">
  <div class="website-menu-container">
    <div class="website-menu-left">
      <a href="#" class="website-menu-brand" data-page="home">Vishwesh Palani</a>
      <nav class="website-menu-nav">
        <a href="#" data-page="education">Education</a>
        <a href="#" data-page="research">Research</a>
        <a href="#" data-page="experience">Experience</a>
      </nav>
    </div>
    <div class="website-menu-icons">
      <a href="https://github.com/vishweshRox" target="_blank" rel="noopener noreferrer">
        <svg class="website-menu-icon" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/>
        </svg>
      </a>
      <a href="https://www.linkedin.com/in/vishwesh-palani/" target="_blank" rel="noopener noreferrer">
        <svg class="website-menu-icon" viewBox="0 0 24 24" fill="currentColor">
          <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
        </svg>
      </a>
    </div>
  </div>
</div>
  
<div class="website-content">
  <div class="website-content-container">
    <div class="website-page active" id="home-page">
      <p>I am a senior at <a href="https://www.umass.edu/" target="_blank" rel="noopener noreferrer" class="website-link">UMass Amherst</a> studying Mathematics and Computer Science. I am currently advised by <a href="https://www.cics.umass.edu/about/directory/mordecai-golin" target="_blank" rel="noopener noreferrer" class="website-link">Dr. Mordecai Golin</a>.</p>
      <p>Feel free to explore the <a href="#" class="website-link terminal-link">terminal</a> and launch <a href="#" class="website-link automata-link">cellular automata</a> featured on this website, or learn more about me in the other webpages linked above.</p>
      <p>For better or worse, this website is a single .html file. The source code for this website can be found <a href="https://github.com/vishweshRox/terminal-emulator-website" target="_blank" rel="noopener noreferrer" class="website-link">here</a>.</p>
    </div>
    
    <div class="website-page" id="education-page">
      <p>During my time at UMass, I've cycled through several choices of study (cs + econ, cs + applied math, cs + pure math) and now I'm studying cs + discrete math (the latter is actually an individually designed track, courtesy of the <a href="https://www.umass.edu/mathematics-statistics/" target="_blank" rel="noopener noreferrer" class="website-link">UMass Math department</a>).</p>
      
      <h3>Academic Honors</h3>
      <p><a href="https://www.pbk.org/" target="_blank" rel="noopener noreferrer" class="website-link">Phi Beta Kappa</a> (elected May 2025)<br>
      Malone Opportunity Scholarship<br>
      Dean's List (all semesters)</p>
      
      <p>Scroll through to see the coursework I've taken through the years (gen-ed requirements have been excluded).</p>
      
      <div style="background: rgba(74, 158, 255, 0.1); border: 1px solid rgba(74, 158, 255, 0.3); border-radius: 8px; padding: 15px; margin: 20px 0;">
        <strong>Course Hierarchy (approximately)</strong><br>
        [100-200) freshman level<br>
        [200-300) sophomore level<br>
        [300-400) junior level<br>
        [400-500) senior level<br>
        [500-600) master's level<br>
        600+ Ph.D. level<br><br>
        
        <strong>Note:</strong> Honors courses have the letter 'H' appended to the course code. Most courses are 3-credit courses, with the exception of some introductory courses being 4-credit courses. Seminars are 1-credit courses.
      </div>

      <h3>Fall '25 (ongoing)</h3>
      <p><span style="color: #ff4444; font-weight: bold;">COMPSCI 601:</span> complexity theory<br>
      <span style="color: #ff4444; font-weight: bold;">COMPSCI 648:</span> quantum information science<br>
      <span style="color: #ff4444; font-weight: bold;">COMPSCI 891:</span> theory seminar</p>
      <p><span style="color: #4A9EFF; font-weight: bold;">MATH 611:</span> algebra I<br>
      <span style="color: #4A9EFF; font-weight: bold;">MATH 491A:</span> putnam seminar</p>

      <h3>Spring '25</h3>
      <p><span style="color: #ff4444; font-weight: bold;">COMPSCI 501:</span> formal language theory<br>
      <span style="color: #ff4444; font-weight: bold;">COMPSCI 514:</span> algorithms for data science<br>
      <span style="color: #ff4444; font-weight: bold;">COMPSCI 396:</span> independent study with <a href="https://www.cics.umass.edu/about/directory/mordecai-golin" target="_blank" rel="noopener noreferrer" class="website-link">Dr. Mordecai Golin</a></p>
      <p><span style="color: #4A9EFF; font-weight: bold;">MATH 412:</span> abstract algebra II</p>

      <h3>Winter '25</h3>
      <p><span style="color: #4A9EFF; font-weight: bold;">MATH 411:</span> abstract algebra I</p>

      <h3>Fall '24</h3>
      <p><span style="color: #ff4444; font-weight: bold;">COMPSCI 589:</span> machine learning<br>
      <span style="color: #ff4444; font-weight: bold;">COMPSCI 311:</span> introduction to algorithms</p>
      
      <p><span style="color: #4A9EFF; font-weight: bold;">MATH 513:</span> combinatorics (cross-listed as <span style="color: #ff4444; font-weight: bold;">COMPSCI 575:</span> combinatorics and graph theory)<br>
      <span style="color: #4A9EFF; font-weight: bold;">MATH 545:</span> applied linear algebra<br>
      <span style="color: #4A9EFF; font-weight: bold;">MATH 331:</span> ordinary differential equations</p>

      <h3>Spring '24</h3>
      <p><span style="color: #ff4444; font-weight: bold;">COMPSCI 250:</span> introduction to computation<br>
      <span style="color: #ff4444; font-weight: bold;">COMPSCI 230:</span> computer systems principles<br>
      <span style="color: #ff4444; font-weight: bold;">COMPSCI 320:</span> software engineering<br>
      <span style="color: #ff4444; font-weight: bold;">COMPSCI 383:</span> artificial intelligence<br>
      <span style="color: #ff4444; font-weight: bold;">COMPSCI 220H:</span> 1-credit honors independent study with <a href="https://www.cics.umass.edu/about/directory/marius-minea" target="_blank" rel="noopener noreferrer" class="website-link">Dr. Marius Minea</a> (honors)</p>

      <h3>Fall '23</h3>
      <p><span style="color: #ff4444; font-weight: bold;">COMPSCI 220:</span> programming methodology<br>
      <span style="color: #ff4444; font-weight: bold;">COMPSCI 240:</span> reasoning under uncertainty</p>
      
      <p><span style="color: #4A9EFF; font-weight: bold;">MATH 235H:</span> introduction to linear algebra (honors)</p>
      
      <p><span style="color: #ff8800; font-weight: bold;">ECON 203H:</span> intermediate microeconomic theory (honors)</p>

      <h3>Spring '23</h3>
      <p><span style="color: #ff4444; font-weight: bold;">COMPSCI 210:</span> data structures<br>
      <span style="color: #ff4444; font-weight: bold;">COMPSCI 198C:</span> introduction to C programming seminar</p>
      
      <p><span style="color: #4A9EFF; font-weight: bold;">MATH 233:</span> multivariate calculus (III)</p>
      
      <p><span style="color: #ff8800; font-weight: bold;">ECON 103:</span> introduction to microeconomics<br>
      <span style="color: #ff8800; font-weight: bold;">ECON 104:</span> introduction to macroeconomics</p>

      <h3>Winter '23</h3>
      <p><span style="color: #ff4444; font-weight: bold;">COMPSCI 160:</span> object oriented programming</p>

      <h3>Fall '22</h3>
      <p><span style="color: #ff4444; font-weight: bold;">INFO 190S:</span> introduction to programming</p>
      
      <p><span style="color: #4A9EFF; font-weight: bold;">MATH 132:</span> calculus II</p>
      
      <br><br><br>
    </div>
    
    <div class="website-page" id="research-page">
      <p>Here are the descriptions for some of research projects I've worked on:</p>
      
      <div class="research-project">
        <h3>Combinatorial Methods for producing optimal AIFV codes</h3>
        <p><a href="https://github.com/vishweshRox/aifv-mcmc-study" target="_blank" rel="noopener noreferrer" class="github-link">
          <svg style="width: 16px; height: 16px; margin-right: 4px; vertical-align: middle;" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
          GitHub
        </a> | <em>Python</em></p>
        <p>Studied existing methods for producing <a href="https://arxiv.org/abs/1507.08733" target="_blank" rel="noopener noreferrer" class="website-link">AIFV codes</a> as well as proofs of optimality (for algorithms and codes) under the supervision of <a href="https://www.cics.umass.edu/about/directory/mordecai-golin" target="_blank" rel="noopener noreferrer" class="website-link">Dr. Mordecai Golin</a>. Connections to the related Minimum-Cost Markov Chain (MCMC) problem were also modelled and studied. Currently studying extensions to problems in finite-state channel coding.</p>
        <p><strong>Topics:</strong> Theoretical Computer Science, Coding Theory, Computational Geometry, Information Theory</p>
      </div>
      
      <div class="research-project">
        <h3>Commuting Matrices over Finite Fields</h3>
      <p><a href="https://github.com/oblomkov-math/REU2025" target="_blank" rel="noopener noreferrer" class="github-link">
        <svg style="width: 16px; height: 16px; margin-right: 4px; vertical-align: middle;" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
        </svg>
        GitHub
      </a> | <em>C++, Python, SageMath</em></p>
        <p>Collaborated with a 2-person team under the supervision of <a href="https://www.umass.edu/mathematics-statistics/about/directory/alexei-oblomkov" target="_blank" rel="noopener noreferrer" class="website-link">Dr. Alexei Oblomkov</a> to study the Commuting Variety over Finite Fields as part of the <a href="http://sites.google.com/umass.edu/math-stat-reu/home?authuser=0" target="_blank" rel="noopener noreferrer" class="website-link">UMass Amherst Mathematics and Statistics REU 2025</a>. Extended results from <a href="https://projecteuclid.org/journals/duke-mathematical-journal/volume-27/issue-1/Pairs-of-commuting-matrices-over-a-finite-field/10.1215/S0012-7094-60-02709-5.short" target="_blank" rel="noopener noreferrer" class="website-link">Feit et al.</a> to count the number of commuting nilpotent matrices over finite fields by studying their possible Jordan formulations. Helped formulate several conjectural formulas for the counting polynomial of the commuting variety defined by the function f (X, Y ) = X²Y², as well as produce supporting empirical data using Sage.</p>
        <p><strong>Topics:</strong> Algebraic Combinatorics, Pure Mathematics</p>
      </div>
      
      <div class="research-project">
        <h3>Geometric Algorithms for Linear Separability Testing</h3>
      <p><a href="https://github.com/kyle-doney/URV-2024" target="_blank" rel="noopener noreferrer" class="github-link">
        <svg style="width: 16px; height: 16px; margin-right: 4px; vertical-align: middle;" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
        </svg>
        GitHub
      </a> | <em>Python, SciPy, cvxpy, G2SAT</em></p>
        <p>This work was done as part of the Undergraduate Research Volunteer (URV) program conducted during Summer '24 by <a href="https://www.cics.umass.edu/" target="_blank" rel="noopener noreferrer" class="website-link">UMass CICS</a>. Our team converted Boolean formulae into subsets of n-dimensional hypercubes and approached SAT problems from the realm of linear separability by implementing a geometric algorithm (proposed by Zhong et al.). We discovered a 95% reduction in runtime when compared to those of cvxpy and SciPy. We also explored the capabilities of the G2SAT generative framework. The team comprised four undergraduates supervised by PhD student Kyle Doney.</p>
        <p><strong>Topics:</strong> Theoretical Machine Learning, Boolean SAT, Deep Generative AI</p>
      </div>
      
      <div class="research-project">
        <h3>Automated Invariant Generation</h3>
      <p><a href="https://github.com/vishweshRox/exploringDaikon" target="_blank" rel="noopener noreferrer" class="github-link">
        <svg style="width: 16px; height: 16px; margin-right: 4px; vertical-align: middle;" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.30.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
        </svg>
        GitHub
      </a> | <em>Java, JUnit, Daikon, RandOOP</em></p>
        <p>Analyzed coverage of loop and class invariants dynamically inferred by Daikon from execution traces across 20+ Java program suites using custom and RandOOP-generated JUnit test suites. Supervised by <a href="https://www.cics.umass.edu/about/directory/marius-minea" target="_blank" rel="noopener noreferrer" class="website-link">Dr. Marius Minea</a> as part of an independent study.</p>
        <p><strong>Topics:</strong> Formal Verification</p>
      </div>
      
      <br><br><br>
    </div>
    
    <div class="website-page" id="experience-page">
      <p>Resume available upon request at vpalani [at] umass [dot] edu.</p>
      
      <h2>Technical Skills</h2>
      
      <div class="skills-section">
        <h3>Languages</h3>
        <div class="skills-grid">
          <div class="skill-item" data-skill="python">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/python/python-original.svg" class="skill-icon" alt="Python">
            <span class="skill-name">Python</span>
          </div>
          <div class="skill-item" data-skill="java">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/java/java-original.svg" class="skill-icon" alt="Java">
            <span class="skill-name">Java</span>
          </div>
          <div class="skill-item" data-skill="c">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/c/c-original.svg" class="skill-icon" alt="C">
            <span class="skill-name">C</span>
          </div>
          <div class="skill-item" data-skill="cpp">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/cplusplus/cplusplus-original.svg" class="skill-icon" alt="C++">
            <span class="skill-name">C++</span>
          </div>
          <div class="skill-item" data-skill="javascript">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/javascript/javascript-original.svg" class="skill-icon" alt="JavaScript">
            <span class="skill-name">JavaScript</span>
          </div>
          <div class="skill-item" data-skill="typescript">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/typescript/typescript-original.svg" class="skill-icon" alt="TypeScript">
            <span class="skill-name">TypeScript</span>
          </div>
          <div class="skill-item" data-skill="sql">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/azuresqldatabase/azuresqldatabase-original.svg" class="skill-icon" alt="SQL">
            <span class="skill-name">Transact-SQL</span>
          </div>
          <div class="skill-item" data-skill="dart">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/dart/dart-original.svg" class="skill-icon" alt="Dart">
            <span class="skill-name">Dart</span>
          </div>
          <div class="skill-item" data-skill="ruby">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/ruby/ruby-original.svg" class="skill-icon" alt="Ruby">
            <span class="skill-name">Ruby</span>
          </div>
          <div class="skill-item" data-skill="xslt">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/xml/xml-original.svg" class="skill-icon" alt="XSLT">
            <span class="skill-name">XSLT</span>
          </div>
        </div>
      </div>

      <div class="skills-section">
        <h3>Frameworks + Libraries</h3>
        <div class="skills-grid">
          <div class="skill-item" data-skill="flutter">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/flutter/flutter-original.svg" class="skill-icon" alt="Flutter">
            <span class="skill-name">Flutter</span>
          </div>
          <div class="skill-item" data-skill="spring">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/spring/spring-original.svg" class="skill-icon" alt="Spring">
            <span class="skill-name">Spring Suite</span>
          </div>
          <div class="skill-item" data-skill="nodejs">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/nodejs/nodejs-original.svg" class="skill-icon" alt="Node.js">
            <span class="skill-name">Node.js</span>
          </div>
          <div class="skill-item" data-skill="express">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/express/express-original.svg" class="skill-icon" alt="Express.js">
            <span class="skill-name">Express.js</span>
          </div>
          <div class="skill-item" data-skill="firebase">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/firebase/firebase-plain.svg" class="skill-icon" alt="Firebase">
            <span class="skill-name">Firebase</span>
          </div>
          <div class="skill-item" data-skill="flask">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/flask/flask-original.svg" class="skill-icon" alt="Flask">
            <span class="skill-name">Flask</span>
          </div>
          <div class="skill-item" data-skill="semantic-kernel">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/dot-net/dot-net-original.svg" class="skill-icon" alt="Semantic Kernel">
            <span class="skill-name">Semantic Kernel</span>
          </div>
        </div>
      </div>

      <div class="skills-section">
        <h3>Machine Learning + Data</h3>
        <div class="skills-grid">
          <div class="skill-item" data-skill="tensorflow">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/tensorflow/tensorflow-original.svg" class="skill-icon" alt="TensorFlow">
            <span class="skill-name">TensorFlow</span>
          </div>
          <div class="skill-item" data-skill="pytorch">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/pytorch/pytorch-original.svg" class="skill-icon" alt="PyTorch">
            <span class="skill-name">PyTorch</span>
          </div>
          <div class="skill-item" data-skill="sklearn">
            <img src="https://upload.wikimedia.org/wikipedia/commons/0/05/Scikit_learn_logo_small.svg" class="skill-icon" alt="Scikit-Learn">
            <span class="skill-name">Scikit-Learn</span>
          </div>
          <div class="skill-item" data-skill="numpy">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/numpy/numpy-original.svg" class="skill-icon" alt="NumPy">
            <span class="skill-name">NumPy</span>
          </div>
          <div class="skill-item" data-skill="scipy">
            <img src="https://scipy.org/images/logo.svg" class="skill-icon" alt="SciPy">
            <span class="skill-name">SciPy</span>
          </div>
        </div>
      </div>

      <div class="skills-section">
        <h3>Databases</h3>
        <div class="skills-grid">
          <div class="skill-item" data-skill="postgresql">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/postgresql/postgresql-original.svg" class="skill-icon" alt="PostgreSQL">
            <span class="skill-name">PostgreSQL</span>
          </div>
          <div class="skill-item" data-skill="snowflake">
            <img src="https://companieslogo.com/img/orig/SNOW-35164165.png" class="skill-icon" alt="Snowflake">
            <span class="skill-name">Snowflake</span>
          </div>
        </div>
      </div>

      <div class="skills-section">
        <h3>Tools + Platforms</h3>
        <div class="skills-grid">
          <div class="skill-item" data-skill="aws">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/amazonwebservices/amazonwebservices-original-wordmark.svg" class="skill-icon" alt="AWS">
            <span class="skill-name">AWS (EC2, S3, RDS, SageMaker, Batch)</span>
          </div>
          <div class="skill-item" data-skill="azure">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/azure/azure-original.svg" class="skill-icon" alt="Azure">
            <span class="skill-name">Azure DevOps</span>
          </div>
          <div class="skill-item" data-skill="jenkins">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/jenkins/jenkins-original.svg" class="skill-icon" alt="Jenkins">
            <span class="skill-name">Jenkins</span>
          </div>
          <div class="skill-item" data-skill="docker">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/docker/docker-original.svg" class="skill-icon" alt="Docker">
            <span class="skill-name">Docker</span>
          </div>
          <div class="skill-item" data-skill="bash">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/bash/bash-original.svg" class="skill-icon" alt="Bash">
            <span class="skill-name">Bash</span>
          </div>
          <div class="skill-item" data-skill="azure-ai-foundry">
            <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/azure/azure-original.svg" class="skill-icon" alt="Azure AI Foundry">
            <span class="skill-name">Azure AI Foundry</span>
          </div>
        </div>
      </div>

      <h2>Industry</h2>

      <div class="industry-experience-container">
        <img src="logos/deevita-logo.jpeg" alt="Deevita LLC Logo" class="industry-logo">
        <div class="industry-experience">
          <div class="industry-content">
            <div class="industry-header">
              <h3 class="industry-org">Deevita LLC</h3>
              <span class="industry-location-date">Redmond, WA | June 2025 - August 2025</span>
            </div>
            <div class="industry-title">AI/ML Software Engineering Intern</div>
            <div class="industry-technologies">Python, XSLT, Semantic Kernel, Azure AI Foundry</div>
            <p class="industry-description">
              I delivered an automated SPL to FHIR document conversion pipeline using multi-stage XSLT 3.0 with Saxon-HE, reducing average conversion time to about 15 seconds per label and cutting costs by 96% compared to market rates. I also engineered AI microservices with Azure Translator and Azure OpenAI (leveraging GPT-5-mini with Mistral 3B fallback) to enable high-fidelity multilingual translation, LLM-based summarization, and QA support for drug labels. In addition, I implemented a cloud-hosted electronic Product Information (ePI) authoring and visualization platform with a Flask frontend and RESTful FHIR APIs to ensure HL7 regulatory compliance.
            </p>
          </div>
        </div>
      </div>

      <div class="industry-experience-container">
        <img src="logos/fidelity-logo.webp" alt="Fidelity Investments Logo" class="industry-logo">
        <div class="industry-experience">
          <div class="industry-content">
            <div class="industry-header">
              <h3 class="industry-org">Fidelity Investments</h3>
              <span class="industry-location-date">Smithfield, RI | May 2024 - August 2024</span>
            </div>
            <div class="industry-title">Data Engineering Intern</div>
            <div class="industry-technologies">Python, Bash, Java, Spring, Control-M, Snowflake, AWS SageMaker</div>
            <p class="industry-description">
              I identified and migrated over 40 critical Spring Batch jobs for record management and database maintenance from on-premise systems to AWS within the Brokerage Business Unit, reducing infrastructure costs by 60%. To accelerate the process, I automated migration tasks with Python and Bash scripts to bypass the Control-M client and optimized XML formatters, achieving a 95% increase in migration speed. I also took on a rotational role with the Autobots (MLOps) team, where I smoke tested more than 10 inference engines on newly developed cloud infrastructure for feature engineering using AWS SageMaker and Snowflake.
            </p>
          </div>
        </div>
      </div>

      <div class="industry-experience-container">
        <img src="logos/healthspan-logo.jpg" alt="Healthspan Fit Logo" class="industry-logo">
        <div class="industry-experience">
          <div class="industry-content">
            <div class="industry-header">
              <h3 class="industry-org">Healthspan Fit</h3>
              <span class="industry-location-date">Santa Clara, CA | March 2024</span>
            </div>
            <div class="industry-title">Freelance</div>
            <div class="industry-technologies">Python, imaplib</div>
            <p class="industry-description">
              Utilized the imaplib Python module to compile mailing/phone lists using all previous digital interactions over a 20 year period, resulting in 3000+ new contacts and an increase in weekly marketing outreach by 30 times.
            </p>
          </div>
        </div>
      </div>

      <div class="industry-experience-container">
        <img src="logos/peppill-logo.jpg" alt="Deevita LLC Logo" class="industry-logo">
        <div class="industry-experience">
          <div class="industry-content">
            <div class="industry-header">
              <h3 class="industry-org">PepPill</h3>
              <span class="industry-location-date">Redmond, WA | June 2023 - November 2023</span>
            </div>
            <div class="industry-title">Software Engineering Intern</div>
            <div class="industry-technologies">T-SQL, Azure DevOps</div>
            <p class="industry-description">
              I collaborated in Agile teams to build critical back-end Transact-SQL components that handled the addition, modification, and publishing of over 100,000 pharmaceutical drug records each day, streamlining workflows and approval processes within a SaaS-based Drug Catalog Management System. I also optimized Azure SQL database interactions and automated key approval stages, reducing manual steps by 70%.
            </p>
          </div>
        </div>
      </div>

      <h2>Projects</h2>
      
      <div class="wildwhere-project">
        <a href="https://sites.google.com/umass.edu/wildwhere/home" target="_blank" rel="noopener noreferrer">
          <img src="logos/wildwhere-logo.png" alt="WildWhere Logo" class="wildwhere-logo">
        </a>
        <p><a href="https://github.com/amandeepksingh/WildWhere?tab=readme-ov-file" target="_blank" rel="noopener noreferrer" class="github-link">
          <svg style="width: 16px; height: 16px; margin-right: 4px; vertical-align: middle;" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
          GitHub
        </a> | <em>Objective-C, C++, Ruby, Flutter, PostgreSQL, JavaScript, Node.js, Express.js, Firebase, AWS (RDS, S3, EC2), Jenkins</em></p>
        <p>Worked jointly with a team of seven to design and deliver WildWhere, a cross-platform iOS and Android mobile mapping app that enables real-time, geo-tagged wildlife sighting reports—complete with species, count, behavior, and timestamp details—provides data export tools for personal analysis and conservation research, and leverages Jenkins-powered CI/CD pipelines for automated builds, testing, and deployments.</p>
      </div>
      
      <div style="height: 100px;"></div>
    </div>
  </div>
</div>

<div id="terminal-wrapper">
<div id="terminal-window">
  <div id="terminal"></div>
  <div class="cli-buttons">
    <!-- Help -->
<button class="btn icon-btn help-btn" data-tip="help" aria-label="Help">
  <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
    <text x="12" y="22" text-anchor="middle" font-size="27" fill="currentColor" font-family="monospace" font-weight="700">?</text>
  </svg>
</button>

<!-- Clear -->
<button class="btn icon-btn clear-btn" data-tip="clear" aria-label="Clear">
  <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
  <!-- clearer, classic tilted eraser + wipe line -->
  <path d="M4 14.6L12.6 6a3 3 0 014.2 0l1.8 1.8a3 3 0 010 4.2l-8.6 8.6H7.1a3 3 0 01-2.1-.9l-1-1a3 3 0 010-4.2z" fill="currentColor"/>
  <rect x="9" y="21" width="10" height="2" rx="1" fill="currentColor"/>
</svg>
</button>

<!-- Keyboard -->
<button class="btn icon-btn keyboard-toggle-btn" data-tip="keyboard" aria-label="Toggle keyboard">
  <svg class="icon" viewBox="0 0 24 24" preserveAspectRatio="none" aria-hidden="true">
    <rect x="3" y="6" width="18" height="12" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
    <g fill="currentColor">
      <rect x="5" y="8" width="2" height="2"/>
      <rect x="8" y="8" width="2" height="2"/>
      <rect x="11" y="8" width="2" height="2"/>
      <rect x="14" y="8" width="2" height="2"/>
      <rect x="17" y="8" width="2" height="2"/>
      <rect x="5" y="11" width="2" height="2"/>
      <rect x="8" y="11" width="8" height="2"/>
      <rect x="17" y="11" width="2" height="2"/>
      <rect x="5" y="14" width="10" height="2"/>
    </g>
  </svg>
</button>

<!-- Theme -->
<button class="btn theme-btn" data-tip="theme --terminal" aria-label="Cycle theme">
  <span class="theme-indicator"></span>
</button>

  </div>
</div>

<div id="keyboard-panel" class="hidden">

<div id="keyboard">
  <div class="key rect long esc"   data-key="Escape">ESC</div>
  <div class="key d1" data-key="Digit1" data-alt="!">1</div>
  <div class="key d2" data-key="Digit2" data-alt="@">2</div>
  <div class="key d3" data-key="Digit3" data-alt="#">3</div>
  <div class="key d4" data-key="Digit4" data-alt="$">4</div>
  <div class="key d5" data-key="Digit5" data-alt="%">5</div>
  <div class="key d6" data-key="Digit6" data-alt="^">6</div>
  <div class="key d7" data-key="Digit7" data-alt="&amp;">7</div>
  <div class="key d8" data-key="Digit8" data-alt="*">8</div>
  <div class="key d9" data-key="Digit9" data-alt="(">9</div>
  <div class="key d0" data-key="Digit0" data-alt=")">0</div>
  <div class="key dash" data-key="Minus"  data-alt="_">-</div>
  <div class="key equal" data-key="Equal" data-alt="+">=</div>
  <div class="key rect long back" data-key="Backspace">del</div>

  <div class="key rect long tab" data-key="Tab">TAB</div>
  <div class="key q" data-key="KeyQ">Q</div>
  <div class="key w" data-key="KeyW">W</div>
  <div class="key e" data-key="KeyE">E</div>
  <div class="key r" data-key="KeyR">R</div>
  <div class="key t" data-key="KeyT">T</div>
  <div class="key y" data-key="KeyY">Y</div>
  <div class="key u" data-key="KeyU">U</div>
  <div class="key i" data-key="KeyI">I</div>
  <div class="key o" data-key="KeyO">O</div>
  <div class="key p" data-key="KeyP">p</div>
  <div class="key lbr"    data-key="BracketLeft"  data-alt="{">[</div>
  <div class="key rbr"    data-key="BracketRight" data-alt="}">]</div>
  <div class="key bslash" data-key="Backslash"     data-alt="|">\</div>
  
  <div class="key rect long caps" data-key="CapsLock">CAPS</div>
  <div class="key a" data-key="KeyA">A</div>
  <div class="key s" data-key="KeyS">S</div>
  <div class="key d" data-key="KeyD">D</div>
  <div class="key f" data-key="KeyF">F</div>
  <div class="key g" data-key="KeyG">G</div>
  <div class="key h" data-key="KeyH">H</div>
  <div class="key j" data-key="KeyJ">J</div>
  <div class="key k" data-key="KeyK">K</div>
  <div class="key l" data-key="KeyL">L</div>
  <div class="key semi"  data-key="Semicolon" data-alt=":">;</div>
  <div class="key quote" data-key="Quote"     data-alt="&quot;">'</div>
  <div class="key rect long enter" data-key="Enter">enter</div>
  
  <div class="key rect long shift-l" data-key="ShiftLeft">SHIFT</div>
  <div class="key z" data-key="KeyZ">Z</div>
  <div class="key x" data-key="KeyX">X</div>
  <div class="key c" data-key="KeyC">C</div>
  <div class="key v" data-key="KeyV">V</div>
  <div class="key b" data-key="KeyB">B</div>
  <div class="key n" data-key="KeyN">N</div>
  <div class="key m" data-key="KeyM">M</div>
  <div class="key comma" data-key="Comma"  data-alt="<">,</div>
  <div class="key dot"   data-key="Period" data-alt=">">.</div>
  <div class="key slash" data-key="Slash"  data-alt="?">/</div>
  
  <div class="key rect long shift-r" data-key="ShiftRight">SHIFT</div>

  <div class="key spacebar" data-key="Space">space</div>
</div>
</div>

</div>
  <div id="help-modal">
    <div class="modal-header">
      <div class="close-btn">×</div>
      <span class="modal-title">help</span>
    </div>
    <input type="text" class="modal-search" placeholder="Search commands…" />
    <div class="modal-body"></div>
  </div>

  <div id="vim-editor">
    <div class="vim-header">
      <div class="vim-close"></div>
      <div class="vim-filename">untitled.txt</div>
    </div>
    <div class="vim-body">
      <div class="vim-sidebar">
        <div class="resize-handle"></div>
        <h4>Explorer</h4>
        <div class="vim-file-tree">
          <div class="file-item">📁 home</div>
          <div class="file-item">📁 etc</div>
          <div class="file-item">📄 about.txt</div>
          <div class="file-item">📄 secret.msg</div>
        </div>
      </div>
      <div class="vim-main">
        <div class="vim-tabs">
          <div class="vim-tab">untitled.txt</div>
        </div>
        <div class="vim-content">
          <textarea class="vim-textarea" placeholder="-- INSERT --"></textarea>
          <div class="vim-message-overlay" id="vim-message-overlay"></div>
        </div>
        <div class="vim-status">
          <div class="vim-mode">-- INSERT --</div>
          <div class="vim-info">Line 1, Col 1 | UTF-8</div>
        </div>
      </div>
    </div>
  </div>  
  <script>
    let zCounter = 2000;
function bringToFront(el) {
  el.style.zIndex = ++zCounter;
}
    const pageLoadTime = new Date();
    const commands = ['welcome','help','clear','exit','ls','cd','cat','mkdir','pwd','theme','keyboard','mv','rmdir','rm','touch','date','grep','vim','download','automata','goto'];
    const fs = {
      type: 'dir', author: 'root', mtime: pageLoadTime, children: {
        home: { type: 'dir', author: 'root', mtime: pageLoadTime, children: {
          user: { type: 'dir', children: {
            'about.txt': { type: 'file', content: 'Welcome! Type "help" to see commands.', author: 'user', mtime: pageLoadTime},
            'secret.msg': { type: 'file', action: showSecret, mtime: pageLoadTime, author: 'user'}
          }, author: 'root', mtime: pageLoadTime}
        }
      },
        etc: { type: 'dir', children: {}, author: 'root', mtime: pageLoadTime }
      }
    , author: 'root', mtime: pageLoadTime};
    const history = [];
    let historyIndex = 0;
    let cwd = ['home', 'user'];
    const terminal = document.getElementById('terminal');

    // Global automaton instances management
    let automatonInstances = [];
    let automatonCounters = { worm: 0, flower: 0, moss: 0 };
    let highlightedAutomatonId = null;

    function resolvePath(path) {
      if (path === '~') return [];
      let base, parts;
      if (path.startsWith('~/')) { base = []; parts = path.slice(2).split('/'); }
      else if (path.startsWith('/')) { base = []; parts = path.slice(1).split('/'); }
      else { base = [...cwd]; parts = path.split('/'); }
      for (let p of parts) {
        if (!p || p === '.') continue;
        if (p === '..') base.pop(); else base.push(p);
      }
      return base;
    }

    function getNode(pathArr) {
      let node = fs;
      for (let part of pathArr) {
        if (!part) continue;
        if (node.type === 'dir' && node.children[part]) node = node.children[part];
        else return null;
      }
      return node;
    }

    function print(text) {
      const line = document.createElement('div');
      line.className = 'output-line';
      line.textContent = text;
      terminal.appendChild(line);
    }

    function showSecret() { print('🔥 Secret Unlocked! 🔥'); }

function formatDate(dt) {
  const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const m = months[dt.getMonth()];
  const d = String(dt.getDate()).padStart(2,' ');
  const h = String(dt.getHours()).padStart(2,'0');
  const mm = String(dt.getMinutes()).padStart(2,'0');
  return `${m} ${d} ${h}:${mm}`;
}

function listDir(arg = '') {
  const parts = arg.split(/\s+/).filter(Boolean);
  const flagTokens = parts.filter(p => p.startsWith('-'));
  const flags = flagTokens.join('');
  const pathArgs = parts.filter(p => !p.startsWith('-'));

  const invalid = flagTokens.filter(f => !/^-[al]+$/.test(f));
  if (invalid.length) {
    print(`ls: invalid option '${invalid[0]}'`);
    return;
  }

  function listOne(targetPath, showHeader) {
    const resolved = targetPath === undefined
      ? cwd
      : resolvePath(targetPath);
    const node = getNode(resolved);
    if (!node) {
      print(`ls: cannot access '${targetPath}': No such file or directory`);
      return;
    }

    if (showHeader) {
      print((targetPath === undefined ? '.' : targetPath) + ':');
    }

    if (node.type === 'dir') {
      let entries = Object.keys(node.children);

      if (flags.includes('a')) {
        entries = ['.','..', ...entries];
      } else {
        entries = entries.filter(n => !n.startsWith('.'));
      }

      if (flags.includes('l')) {
        entries.forEach(name => {
          
          if (name === '.' || name === '..') {
            const owner = node.author || 'unknown';
            const mtime = formatDate(node.mtime ? new Date(node.mtime) : new Date());
            print(`drwxr-xr-x ${owner} ${mtime} ${name}`);
            return;
          }
          const child = node.children[name];
          const perm = child.type === 'dir' ? 'drwxr-xr-x' : '-rw-r--r--';
          const owner = child.author || 'unknown';
          const mtime = formatDate(child.mtime ? new Date(child.mtime) : new Date());
          print(`${perm} ${owner} ${mtime} ${name}`);
        });
      } else {
        print(entries.join('  '));
      }
    } else {

  if (showHeader) {
    
    print(`ls: ${targetPath}: Not a directory`);
  } else {
    
    if (flags.includes('l')) {
      const perm = '-rw-r--r--';
      const owner = node.author || 'unknown';
      const mtime = formatDate(node.mtime ? new Date(node.mtime) : new Date());
      print(`${perm} ${owner} ${mtime} ${targetPath.split('/').pop()}`);
    } else {
      print(targetPath);
    }
  }
  }
  }
  if (!pathArgs.length) {
    // no explicit paths → current directory
    listOne(undefined, false);
  } else {
    const multi = pathArgs.length > 1;
    pathArgs.forEach((p, i) => {
      listOne(p, multi);
      if (multi && i < pathArgs.length - 1) print(''); // blank line between groups
    });
  }
}

   

    function changeDir(arg) { const tgt = arg ? resolvePath(arg) : []; const node = getNode(tgt); if (node && node.type === 'dir') cwd = tgt; else print('cd: no such file or directory: ' + arg); }
    function makeDir(arg) { if (!arg) return print('mkdir: missing operand'); const parts = resolvePath(arg), name = parts.pop(), parent = getNode(parts); if (parent && parent.type === 'dir') parent.children[name] = { type: 'dir', children: {} }; else print('mkdir: cannot create directory ' + arg); }
    function catFile(arg) { if (!arg) return print('cat: missing file operand'); const node = getNode(resolvePath(arg)); if (node && node.type === 'file') { if (node.content) print(node.content); else if (node.action) node.action(); } else print('cat: ' + arg + ': No such file'); }
    function clearTerminal() { terminal.innerHTML = ''; }
    // move (rename) a node
function moveNode(src, dest) {
  const srcArr = resolvePath(src), destArr = resolvePath(dest);
  const name = srcArr.pop(), parent = getNode(srcArr);
  const targetParentArr = destArr.slice(0, -1), newName = destArr.slice(-1)[0];
  const targetParent = getNode(targetParentArr);
  if (!parent || !parent.children[name]) return print(`mv: cannot stat '${src}'`);
  if (!targetParent || targetParent.type !== 'dir') return print(`mv: cannot move to '${dest}'`);
  targetParent.children[newName] = parent.children[name];
  delete parent.children[name];
}

// remove directory (empty or recursive)
function removeDir(arg, recursive = false) {
  const pathArr = resolvePath(arg);
  const parentArr = pathArr.slice(0, -1), name = pathArr.slice(-1)[0];
  const parent = getNode(parentArr), node = getNode(pathArr);
  if (!node || node.type !== 'dir') return print(`rmdir: failed to remove '${arg}'`);
  if (Object.keys(node.children).length && !recursive)
    return print(`rmdir: directory not empty: '${arg}'`);
  // recursive: delete entire subtree
  delete parent.children[name];
}

// remove file or directory
function removeNode(arg, recursive = false) {
  const pathArr = resolvePath(arg);
  const parentArr = pathArr.slice(0, -1), name = pathArr.slice(-1)[0];
  const parent = getNode(parentArr), node = getNode(pathArr);
  if (!node) return print(`rm: cannot remove '${arg}'`);
  if (node.type === 'dir') {
    if (!recursive) return print(`rm: cannot remove '${arg}': Is a directory`);
    delete parent.children[name];
  } else {
    delete parent.children[name];
  }
}

function touchFile(arg) {
  const pathArr = resolvePath(arg);
  const parentArr = pathArr.slice(0, -1), name = pathArr.slice(-1)[0];
  const parent = getNode(parentArr);
  if (!parent || parent.type !== 'dir') {
    return print(`touch: cannot touch '${arg}'`);
  }
  if (parent.children[name]) {
    // existing file: just update its modification time
    parent.children[name].mtime = new Date();
  } else {
    // new file: create with correct metadata
    parent.children[name] = {
      type: 'file',
      content: '',
      author: 'user',
      mtime: new Date()
    };
  }
}

// grep pattern in file
function grep(pattern, filename) {
  const node = getNode(resolvePath(filename));
  if (!node || node.type !== 'file' || typeof node.content !== 'string')
    return print(`grep: ${filename}: No such file`);
  const re = new RegExp(pattern, 'i');
  node.content.split('\n').forEach(line => {
    if (re.test(line)) print(line);
  });
}

function refreshPromptOverlay() {
  const input = document.querySelector('.prompt-input');
  if (input) updateOverlay(input);
}


  function toggleTheme() {
  const b = document.body;
  // cycle: dark → light → blue → dark
  if (!b.classList.contains('light-theme') && !b.classList.contains('blue-theme') && !b.classList.contains('dark-theme')) {
    // Currently default (dark), switch to light
    b.classList.add('light-theme');
  } else if (b.classList.contains('light-theme')) {
    // Currently light, switch to blue
    b.classList.remove('light-theme');
    b.classList.add('blue-theme');
  } else if (b.classList.contains('blue-theme')) {
    // Currently blue, switch to dark
    b.classList.remove('blue-theme');
    b.classList.add('dark-theme');
  } else {
    // Currently dark-theme, cycle back to light
    b.classList.remove('dark-theme');
    b.classList.add('light-theme');
  }
  
  refreshHistoryColors();
  updateIndicator();
  refreshPromptOverlay();
  
}


    function showPrompt() {
      const bar = document.createElement('div'); bar.className = 'prompt-bar';
      
      const ps = document.createElement('span');
ps.className = 'prompt-path';

const parts = ['~', ...cwd];
const elems = []; // keep references to highlight prefix

parts.forEach((part, idx) => {
  if (idx === 0) {
    const seg = document.createElement('span');
    seg.className = 'path-seg';
    seg.textContent = '~';
    ps.appendChild(seg);
    elems.push(seg);

    seg.addEventListener('mouseenter', () => {
      // highlight prefix "~"
      elems.forEach(e => e.classList.remove('active-prefix'));
      seg.classList.add('active-prefix');
    });
    seg.addEventListener('mouseleave', () => {
      elems.forEach(e => e.classList.remove('active-prefix'));
    });
    seg.addEventListener('click', () => autoTypeAndRun('cd /'));
  } else {
    const slash = document.createElement('span');
    slash.className = 'path-slash';
    slash.textContent = '/';
    ps.appendChild(slash);
    elems.push(slash);

    slash.addEventListener('mouseenter', () => {
  // highlight everything up to *and including* this slash
  elems.forEach(e => e.classList.remove('active-prefix'));
  const endIndex = elems.indexOf(slash);
  for (let i = 0; i <= endIndex; i++) {
    elems[i].classList.add('active-prefix');
  }
});

slash.addEventListener('mouseleave', () => {
  elems.forEach(e => e.classList.remove('active-prefix'));
});


    const seg = document.createElement('span');
    seg.className = 'path-seg';
    seg.textContent = part;
    ps.appendChild(seg);
    elems.push(seg);

    seg.addEventListener('mouseenter', () => {
      // highlight all elements up to this segment (include trailing slash)
      elems.forEach(e => e.classList.remove('active-prefix'));
      // find index of this seg in elems and mark prefix
      const endIndex = elems.indexOf(seg);
      for (let i = 0; i <= endIndex; i++) {
        elems[i].classList.add('active-prefix');
      }
      // also highlight a trailing slash visually by adding class to next slash if exists
      const nextSlash = elems[endIndex + 1];
      if (nextSlash && nextSlash.classList.contains('path-slash')) {
        nextSlash.classList.add('active-prefix');
      }
    });
    seg.addEventListener('mouseleave', () => {
      elems.forEach(e => e.classList.remove('active-prefix'));
    });
    seg.addEventListener('click', () => {
      const absPath = '/' + parts.slice(1, idx + 1).join('/');
      autoTypeAndRun('cd ' + absPath);
    });
  }
});

bar.appendChild(ps);





      const wrap = document.createElement('div'); wrap.className = 'input-wrapper';
      const overlayContainer = document.createElement('div'); overlayContainer.className = 'overlay-container'; wrap.appendChild(overlayContainer);
      const input = document.createElement('input'); input.className = 'prompt-input'; wrap.appendChild(input);
      const sugg = document.createElement('span'); sugg.className = 'suggestion'; wrap.appendChild(sugg);
      bar.appendChild(wrap);
      const ts = document.createElement('span'); ts.className = 'prompt-time'; ts.textContent = new Date().toLocaleTimeString('en-GB', { hour12: false }); bar.appendChild(ts);
      terminal.appendChild(bar); 
      
      // Set up proper cursor positioning before focusing
      updateOverlay(input); 
      updateSuggestion(input, sugg); 
      updateCursor(input, wrap);
      
      // Focus and scroll after DOM is updated
      input.focus(); 
      terminal.scrollTop = terminal.scrollHeight;
      
      // Force cursor position update after focus
      setTimeout(() => updateCursor(input, wrap), 0);
      
      input.addEventListener('input', () => { updateOverlay(input); updateSuggestion(input, sugg); updateCursor(input, wrap); });
      input.addEventListener('click', () => updateCursor(input, wrap));
      input.addEventListener('keydown', e => handleKeydown(e, input, sugg, wrap));
      input.addEventListener('keyup', () => updateCursor(input, wrap));
      document.addEventListener('selectionchange', () => {
        const active = document.activeElement;
        if (active === input) updateCursor(input, wrap);
      });
    }

    function updateOverlay(input) {
      const wrap = input.parentElement;
      wrap.querySelectorAll('.cmd-overlay').forEach(el => el.remove());
      const raw = input.value;
      const segs = raw.split(';'); let prefix = '';
      const font = getComputedStyle(input).font;
      for (let idx = 0; idx < segs.length; idx++) {
        const seg = segs[idx]; const trimmed = seg.trim();
        if (!trimmed) { prefix += seg + (idx < segs.length - 1 ? ';' : ''); continue; }
        const token = trimmed.split(' ')[0];
        const before = seg.slice(0, seg.indexOf(trimmed));
        const pr = prefix + before;
        const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); ctx.font = font;
        const space = ctx.measureText(' ').width;
        const halfSpace = space / 2;
        const x = ctx.measureText(pr).width + 8 + space;
        const el = document.createElement('span'); el.className = 'cmd-overlay'; el.textContent = token;
        el.style.left = (x + halfSpace) + 'px';
        el.style.width = ctx.measureText(token).width + 'px';
        // command color: darker in light mode, original in dark
        if (document.body.classList.contains('light-theme')) {
          el.style.color = commands.includes(token) ? '#080' : '#f55';
        } else {
          el.style.color = commands.includes(token) ? '#5f5' : '#f55';
        }
        wrap.appendChild(el);
        prefix += seg + (idx < segs.length - 1 ? ';' : '');
      }
    }

    function updateSuggestion(input, sugg) {
  const raw = input.value;
  const segment = raw.includes(';') ? raw.split(';').pop() : raw;
  const trimmed = segment.trimStart();
  if (!trimmed) {
    sugg.textContent = '';
    return;
  }

  const parts = trimmed.split(/\s+/);
  const cmd = parts[0] || '';

  // All tokens after the command
  const argsAfterCmd = parts.slice(1);

  // Determine the token we're currently typing:
  // ignore earlier flags/args; use the *last* token if it is not a flag.
  const lastToken = argsAfterCmd[argsAfterCmd.length - 1] || '';
  const currentArg = (lastToken.startsWith('-') ? '' : lastToken);

  // If we are in the middle of typing a flag (e.g. "-l") → no suggestion
  if (!currentArg && argsAfterCmd.some(t => !t.startsWith('-'))) {
    sugg.textContent = '';
    return;
  }

  // Build list of directory entries depending on command
  let suggestionText = '';

  if (!argsAfterCmd.length || !currentArg) {
    // No path yet → suggest command name itself
    if (!argsAfterCmd.length) {
      const m = commands.find(c => c.startsWith(cmd));
      if (m) suggestionText = m.slice(cmd.length);
    } else if (cmd === 'automata') {
      // Suggest automata subcommands
      const subcommands = ['create', 'modify', 'deactivate-all', 'list', 'rename', 'help', '--menu', '--information'];
      const currentSub = argsAfterCmd[0] || '';
      const match = subcommands.find(s => s.startsWith(currentSub));
      if (match) suggestionText = match.slice(currentSub.length);
    } else if (cmd === 'theme') {
      // Suggest theme flags
      const themeFlags = ['--terminal', '--webpage', '--light', '--blue', '--dark'];
      const currentFlag = argsAfterCmd[0] || '';
      const match = themeFlags.find(f => f.startsWith(currentFlag));
      if (match) suggestionText = match.slice(currentFlag.length);
    } else if (cmd === 'goto') {
      // Suggest goto destinations
      const destinations = ['home', 'research', 'experience', 'education', 'github', 'linkedin'];
      const currentDest = argsAfterCmd[0] || '';
      const match = destinations.find(d => d.startsWith(currentDest));
      if (match) suggestionText = match.slice(currentDest.length);
    }
    sugg.textContent = suggestionText;
    sugg.style.left = 'calc(var(--cursor-left) + 1ch)';
    return;
  }

  // Special handling for automata command
  if (cmd === 'automata') {
    const subcommand = argsAfterCmd[0];
    const currentToken = argsAfterCmd[argsAfterCmd.length - 1] || '';
    
    if (currentToken.startsWith('--')) {
      // Suggest flags based on subcommand
      let flags = [];
      if (subcommand === 'create') {
        flags = ['--type=', '--name=', '--random', '--help'];
      } else if (subcommand === 'modify') {
        flags = ['--name=', '--rename=', '--scope', '--deactivate', '--help'];
      } else if (subcommand === 'deactivate-all') {
        flags = ['--help'];
      }
      
      const match = flags.find(f => f.startsWith(currentToken));
      if (match) {
        suggestionText = match.slice(currentToken.length);
      }
    } else if (currentToken.includes('=')) {
      // Suggest values for specific flags
      const [flagPart, valuePart] = currentToken.split('=');
      if (flagPart === '--type') {
        const types = ['worm', 'flower', 'moss'];
        const match = types.find(t => t.startsWith(valuePart));
        if (match) suggestionText = match.slice(valuePart.length);
      }
    } else if (!subcommand) {
      // Still typing subcommand
      const subcommands = ['create', 'modify', 'deactivate-all', 'list', 'rename', 'help', '--menu', '--information'];
      const match = subcommands.find(s => s.startsWith(currentToken));
      if (match) suggestionText = match.slice(currentToken.length);
    }
    
    sugg.textContent = suggestionText;
    sugg.style.left = 'calc(var(--cursor-left) + 1ch)';
    return;
  }

  // For path suggestions use only the currentArg (last token)
  const basePath = currentArg;
  // Resolve directory to inspect
  const arr = resolvePath(basePath);
  const dirArr = basePath.endsWith('/') ? arr : arr.slice(0, -1);
  const parent = getNode(dirArr) || { type: 'dir', children: {} };

  let entries;
  if (['cd', 'ls', 'mkdir'].includes(cmd)) {
    entries = Object.keys(parent.children).filter(n => parent.children[n].type === 'dir');
  } else if (['cat', 'open'].includes(cmd)) {
    entries = Object.keys(parent.children);
  } else {
    sugg.textContent = '';
    return;
  }

  const fragment = basePath.endsWith('/') ? '' : basePath.split('/').pop();
  const match = entries.find(n => n.startsWith(fragment));
  if (match) {
    const suffix = match.slice(fragment.length);
    const isDir = parent.children[match] && parent.children[match].type === 'dir';
    suggestionText = suffix + (isDir ? '/' : '');
  }

  sugg.textContent = suggestionText;
  sugg.style.left = 'calc(var(--cursor-left) + 1ch)';
}

// Keep a small gap between the caret and the time chip
const AUTO_EXPAND_MARGIN = 8;      // px
const AUTO_EXPAND_VIEWPORT_PAD = 16; // px from the right edge of the viewport
const BUTTON_AREA_WIDTH = 140;     // px reserved for floating button panel (3 buttons + gaps + panel padding + margin)


function updateCursor(input, wrap) {
  const sel = input.selectionStart;
  const txt = input.value.slice(0, sel);

  const csInput = getComputedStyle(input);
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.font = csInput.font;

  const w = ctx.measureText(txt).width + parseFloat(csInput.paddingLeft || '0');
  const space = ctx.measureText(' ').width;

  // existing caret placement
  wrap.style.setProperty('--cursor-left', `${input.offsetLeft + w}px`);
  wrap.style.setProperty('--cursor-width', `${space}px`);

  // --- AUTO-EXPAND: prevent terminal from overlapping with floating buttons ---
  const bar = input.closest('.prompt-bar');
  const timeChip = bar ? bar.querySelector('.prompt-time') : null;
  if (!bar || !timeChip) return;

  // caret X within the bar (mirrors ::after's left: calc(var(--cursor-left) + 1ch))
  const caretXInBar = wrap.offsetLeft + input.offsetLeft + w + space;
  const timeLeftInBar = timeChip.offsetLeft;

  const overlap = caretXInBar + AUTO_EXPAND_MARGIN - timeLeftInBar;
  if (overlap > 0) {
    const win = document.getElementById('terminal-window');
    const rect = win.getBoundingClientRect();
    
    // Calculate max width considering button area
    const availableWidth = window.innerWidth - BUTTON_AREA_WIDTH - AUTO_EXPAND_VIEWPORT_PAD;
    const terminalLeft = rect.left;
    const maxAllowedWidth = availableWidth - terminalLeft;
    
    const maxWidth = Math.max(320, Math.min(maxAllowedWidth, window.innerWidth - AUTO_EXPAND_VIEWPORT_PAD));
    const newWidth = Math.min(rect.width + overlap, maxWidth);
    
    // Only expand if we won't overlap with buttons
    if (terminalLeft + newWidth < window.innerWidth - BUTTON_AREA_WIDTH) {
      win.style.width = newWidth + 'px';
    }
  }
}


    function finalizePrompt(input) {
      const bar = input.closest('.prompt-bar');
      bar.querySelector('.prompt-path').remove();
      const timeEl = bar.querySelector('.prompt-time');
      const ts = timeEl ? timeEl.textContent : '';
      if (timeEl) timeEl.remove();
      input.parentElement.remove();
      const hist = document.createElement('span'); hist.className = 'history-arrows';
      ['arrow1', 'arrow2', 'arrow3'].forEach(cls => { const sp = document.createElement('span'); sp.className = cls; hist.appendChild(sp); });
      bar.appendChild(hist);
      const tokens = input.value.split(';').map(t => t.trim()).filter(t => t);
      tokens.forEach((t, i) => {
        const cmd = t.split(' ')[0], rest = t.slice(cmd.length);
        const cs = document.createElement('span'); cs.textContent = cmd; cs.classList.add('history-cmd');
        // history command coloring
        if (document.body.classList.contains('light-theme')) {
          cs.style.color = commands.includes(cmd) ? '#080' : '#f55';
        } else {
          cs.style.color = commands.includes(cmd) ? '#5f5' : '#f55';
        }
        bar.appendChild(cs);
        if (rest) { const as = document.createElement('span'); as.className = 'history-arg'; as.textContent = rest; bar.appendChild(as); }
        if (i < tokens.length - 1) { const d = document.createElement('span'); d.textContent = '; '; bar.appendChild(d); }
      });
      if (ts) { const ft = document.createElement('span'); ft.className = 'final-time'; ft.textContent = ts; bar.appendChild(ft); }
    }

    function updateIndicator() {
  const indicator = document.querySelector('.theme-indicator');
  if (!indicator) return;
  if (!document.body.classList.contains('light-theme') &&
      !document.body.classList.contains('blue-theme')) {
    // dark -> next is light
    indicator.style.background = '#fff';
  } else if (document.body.classList.contains('light-theme')) {
    // light -> next is blue
    indicator.style.background = 'var(--blue-bg)';
  } else {
    // blue -> next is dark
    indicator.style.background = '#000';
  }
}

function refreshHistoryColors() {
  document.querySelectorAll('.history-cmd').forEach(el => {
    const cmd = el.textContent;
    if (document.body.classList.contains('light-theme')) {
      el.style.color = commands.includes(cmd) ? '#080' : '#f55';
    } else {
      // dark or blue share same colors
      el.style.color = commands.includes(cmd) ? '#5f5' : '#f55';
    }
  });
}

// Keep Enter flash visible before we hide the keyboard
const ENTER_FLASH_MS = 200; // tweak to taste


function executeCommand(cmd, arg) {
  arg = arg || '';
  switch (cmd) {
    case 'help':
      if (arg.trim()) {
        print('help: unexpected argument: ' + arg.trim());
        break;
      }
      if (document.getElementById('help-modal').style.display === 'block') {
        document.querySelector('.modal-search').focus();
      } else {
        showHelpModal();
      }
      break;

    case 'welcome':
      if (arg.trim()) {
        print('welcome: unexpected argument: ' + arg.trim());
        break;
      }
      print(`Welcome to the command line interface (CLI) for this website! If you're new to Linux, don't worry! Type 'help' or click on the '?' icon below to see the help menu. Most basic Linux commands are supported by this terminal.

You can also interact with the website using some custom commands. To close the terminal, type 'exit' and hit enter. To reopen it (or close it), use the terminal icon at the bottom right corner of the website. Enjoy!`);
      break;

    case 'clear':
      if (arg.trim()) {
        print('clear: unexpected argument: ' + arg.trim());
        break;
      }
      clearTerminal();
      break;

    case 'exit':
      if (arg.trim()) {
        print('exit: unexpected argument: ' + arg.trim());
        break;
      }
      
      // Close all terminal-related windows first
      // Close vim editor if open
      const vimEditor = document.getElementById('vim-editor');
      if (vimEditor && vimEditor.style.display !== 'none') {
        // Auto-save vim file before closing
        if (typeof saveVimFile === 'function') saveVimFile();
        // Close vim editor
        if (typeof closeVimEditor === 'function') closeVimEditor();
      }
      
      // Close help modal
      const helpModal = document.getElementById('help-modal');
      if (helpModal && helpModal.style.display === 'block') {
        helpModal.style.display = 'none';
      }
      
      // Close keyboard panel
      const keyboardPanel = document.getElementById('keyboard-panel');
      if (keyboardPanel && !keyboardPanel.classList.contains('hidden')) {
        keyboardPanel.classList.add('hidden');
      }
      
      // Clear any vim message overlays
      const messageOverlay = document.querySelector('.vim-message-overlay');
      if (messageOverlay) {
        messageOverlay.classList.remove('show');
      }
      
      // Close the terminal window
      const terminalWindow = document.getElementById('terminal-window');
      terminalWindow.classList.remove('show');
      terminalWindow.classList.add('hide');
      // Hide completely after animation
      setTimeout(() => {
        terminalWindow.style.display = 'none';
      }, 250); // Match the animation duration
      break;

    case 'keyboard': {
  if (arg.trim()) { print('keyboard: unexpected argument: ' + arg.trim()); break; }
  const panel = document.getElementById('keyboard-panel');
  const visible = !panel.classList.contains('hidden');

  if (visible) {
    // Delay hiding so the Enter key flash is visible
    setTimeout(() => panel.classList.add('hidden'), ENTER_FLASH_MS);
  } else {
    // Position keyboard below terminal with appropriate scaling and gap
    positionKeyboardBelowTerminal(panel);
    // Show with animation
    panel.classList.remove('hidden');
    bringToFront(panel);
  }
  break;
}



    case 'ls':
      listDir(arg);
      break;

      case 'cd': {
  const parts = arg.trim().split(/\s+/).filter(Boolean);
  if (!parts.length) { print('cd: missing operand'); break; }
  if (parts.length > 1) { print('cd: too many arguments'); break; }
  changeDir(parts[0]);
  break;
}


    case 'cat':
      if (!arg.trim()) { print(cmd + ': missing file operand'); break; }
      catFile(arg);
      break;

    case 'mkdir':
      if (!arg.trim()) { print('mkdir: missing operand'); break; }
      makeDir(arg);
      break;

    case 'pwd':
      if (arg.trim()) { print('pwd: unexpected argument: ' + arg.trim()); break; }
      print('/' + (cwd.length ? cwd.join('/') : ''));
      break;

    case 'theme': {
      const f = arg.trim();
      if (!f) {
        print('theme: flag required');
        print('Usage: theme [--terminal|--webpage|--light|--blue|--dark]');
        print('  --terminal  Toggle terminal color scheme');
        print('  --webpage   Toggle website light/dark mode');
        print('  --light     Set terminal to light theme');
        print('  --blue      Set terminal to blue theme');
        print('  --dark      Set terminal to dark theme');
        break;
      } else if (f === '--terminal') {
        toggleTheme();                // cycle terminal theme
      } else if (f === '--webpage') {
        // Toggle website light/dark mode
        const body = document.body;
        const themeToggleBtn = document.querySelector('.theme-toggle-btn');
        const currentlyDark = !body.classList.contains('light-mode');
        
        if (currentlyDark) {
          body.classList.add('light-mode');
          themeToggleBtn.classList.add('light-mode');
          themeToggleBtn.setAttribute('data-tip', 'Dark Mode');
          print('Switched to light mode');
        } else {
          body.classList.remove('light-mode');
          themeToggleBtn.classList.remove('light-mode');
          themeToggleBtn.setAttribute('data-tip', 'Light Mode');
          print('Switched to dark mode');
        }
      } else if (['--light','--blue','--dark'].includes(f)) {
        // apply explicit terminal theme
        if (f === '--light') {
          document.body.classList.add('light-theme');
          document.body.classList.remove('blue-theme', 'dark-theme');
        } else if (f === '--blue') {
          document.body.classList.add('blue-theme');
          document.body.classList.remove('light-theme', 'dark-theme');
        } else { // --dark
          document.body.classList.add('dark-theme');
          document.body.classList.remove('light-theme', 'blue-theme');
        }
      } else {
        print(`theme: unknown option ${f}`);
        print('Usage: theme [--terminal|--webpage|--light|--blue|--dark]');
        print('  --terminal  Toggle terminal color scheme');
        print('  --webpage   Toggle website light/dark mode');
        print('  --light     Set terminal to light theme');
        print('  --blue      Set terminal to blue theme');
        print('  --dark      Set terminal to dark theme');
        break;
      }
      refreshHistoryColors(); // update previous commands
      updateIndicator();      // update next-theme dot
      refreshPromptOverlay();
      break;
    }

    case 'mv': {
      const parts = arg.trim().split(/\s+/).filter(Boolean);
      if (parts.length !== 2) {
        print('mv: usage: mv <src> <dest>');
        break;
      }
      moveNode(parts[0], parts[1]);
      break;
    }

    case 'rmdir': {
      const parts = arg.trim().split(/\s+/).filter(Boolean);
      const flags = parts.filter(p => p.startsWith('-'));
      const targets = parts.filter(p => !p.startsWith('-'));
      if (!targets.length) { print('rmdir: missing operand'); break; }
      if (flags.some(f => f !== '-r')) { print('rmdir: invalid option'); break; }
      removeDir(targets[0], flags.includes('-r'));
      break;
    }

    case 'rm': {
      const parts = arg.trim().split(/\s+/).filter(Boolean);
      const flags = parts.filter(p => p.startsWith('-'));
      const targets = parts.filter(p => !p.startsWith('-'));
      if (!targets.length) { print('rm: missing operand'); break; }
      if (flags.some(f => f !== '-r')) { print('rm: invalid option'); break; }
      removeNode(targets[0], flags.includes('-r'));
      break;
    }

    case 'touch':
      if (!arg.trim()) { print('touch: missing operand'); break; }
      touchFile(arg.trim());
      break;

    case 'date':
      if (arg.trim()) { print('date: unexpected argument: ' + arg.trim()); break; }
      print(new Date().toString());
      break;

    case 'grep': {
      const parts = arg.trim().split(/\s+/).filter(Boolean);
      if (parts.length < 2) {
        print('grep: usage: grep <pattern> <file>');
        break;
      }
      const pattern = parts[0];
      const file = parts.slice(1).join(' ');
      grep(pattern, file);
      break;
    }

    case 'vim': {
      if (!arg.trim()) {
        print('vim: missing filename');
        break;
      }
      openVimEditor(arg.trim());
      break;
    }

    case 'download': {
      const filename = arg.trim() || getCurrentVimFilename();
      if (!filename) {
        print('download: no file to download');
        break;
      }
      downloadVimFile(filename);
      break;
    }

    case 'automata': {
      try {
        executeCellularAutomataCommand(arg);
      } catch (error) {
        console.error('Automata command error:', error);
        print(`automata: command failed - ${error.message || 'unknown error'}`);
      }
      break;
    }

    case 'goto': {
      const target = arg.trim().toLowerCase();
      if (!target) {
        print('goto: missing destination');
        print('Usage: goto <destination>');
        print('Available destinations: home, research, experience, education, github, linkedin');
        break;
      }
      
      const parts = arg.trim().split(/\s+/).filter(Boolean);
      if (parts.length !== 1) {
        print('goto: exactly one argument required');
        print('Usage: goto <destination>');
        print('Available destinations: home, research, experience, education, github, linkedin');
        break;
      }
      
      switch (target) {
        case 'home':
          // Navigate to home page
          document.querySelector('[data-page="home"]').click();
          print('Navigated to home page');
          break;
        case 'research':
          document.querySelector('[data-page="research"]').click();
          print('Navigated to research page');
          break;
        case 'experience':
          document.querySelector('[data-page="experience"]').click();
          print('Navigated to experience page');
          break;
        case 'education':
          document.querySelector('[data-page="education"]').click();
          print('Navigated to education page');
          break;
        case 'github':
          window.open('https://github.com/vishweshRox', '_blank');
          print('Opened GitHub profile in new tab');
          break;
        case 'linkedin':
          window.open('https://linkedin.com/in/vishweshpalani', '_blank');
          print('Opened LinkedIn profile in new tab');
          break;
        default:
          print(`goto: unknown destination '${target}'`);
          print('Available destinations: home, research, experience, education, github, linkedin');
      }
      break;
    }

    default:
      print(cmd + ': command not found');
  }
}

    // Cellular Automata Command Handler
    function executeCellularAutomataCommand(args) {
      try {
        const tokens = parseCommand(args);
        const subcommand = tokens.args[0];
        
        // Handle direct flags first
        if (tokens.flags.help || subcommand === '--help' || subcommand === 'help') {
          printCellularAutomataHelp();
          return;
        }
        
        if (tokens.flags.menu) {
          // Toggle automata menu
          const caMenu = document.querySelector('.ca-menu');
          if (caMenu.style.display === 'none' || !caMenu.style.display) {
            caMenu.style.display = 'flex';
            print('Automata menu opened');
          } else {
            caMenu.style.display = 'none';
            print('Automata menu closed');
          }
          return;
        }
        
        if (tokens.flags.information) {
          // Toggle automata information modal
          const modal = document.getElementById('ca-info-modal');
          if (modal.style.display === 'none' || !modal.style.display) {
            showCAInfo();
            print('Automata information opened');
          } else {
            hideCAInfo();
            print('Automata information closed');
          }
          return;
        }
        
        if (!subcommand) {
          print('automata: missing subcommand or flag');
          print('Usage: automata <create|modify|deactivate-all|list|rename|--menu|--information> [options]');
          print('       automata --menu           # Toggle automata menu');
          print('       automata --information    # Toggle automata info window');
          print('Try: automata --help');
          return;
        }
        
        switch (subcommand) {
          case 'create':
            handleCellularAutomataCreate(tokens);
            break;
          case 'modify':
            handleCellularAutomataModify(tokens);
            break;
          case 'deactivate-all':
            handleCellularAutomataDeactivateAll(tokens);
            break;
          case 'list':
            handleCellularAutomataList(tokens);
            break;
          case 'rename':
            handleCellularAutomataRename(tokens);
            break;
          default:
            print(`automata: unknown subcommand '${subcommand}'`);
            print('Try: automata --help');
        }
      } catch (error) {
        console.error('Automata command execution error:', error);
        print(`automata: command execution failed - ${error.message || 'unknown error'}`);
      }
    }
    
    // Parse command line arguments into flags and positional args
    function parseCommand(input) {
      // Enhanced parsing to handle quoted strings
      const tokens = [];
      let current = '';
      let inQuotes = false;
      let quoteChar = '';
      
      for (let i = 0; i < input.length; i++) {
        const char = input[i];
        
        if (!inQuotes && (char === '"' || char === "'")) {
          inQuotes = true;
          quoteChar = char;
        } else if (inQuotes && char === quoteChar) {
          inQuotes = false;
          quoteChar = '';
        } else if (!inQuotes && /\s/.test(char)) {
          if (current.trim()) {
            tokens.push(current.trim());
            current = '';
          }
        } else {
          current += char;
        }
      }
      
      if (current.trim()) {
        tokens.push(current.trim());
      }
      
      const flags = {};
      const args = [];
      
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        if (token.startsWith('--')) {
          const flagContent = token.slice(2);
          if (flagContent.includes('=')) {
            const [key, ...valueParts] = flagContent.split('=');
            let value = valueParts.join('=');
            // Remove quotes if present
            if ((value.startsWith('"') && value.endsWith('"')) || 
                (value.startsWith("'") && value.endsWith("'"))) {
              value = value.slice(1, -1);
            }
            flags[key] = value;
          } else {
            flags[flagContent] = true;
          }
        } else if (token.startsWith('-')) {
          const flagContent = token.slice(1);
          if (flagContent.includes('=')) {
            const [key, ...valueParts] = flagContent.split('=');
            let value = valueParts.join('=');
            // Remove quotes if present
            if ((value.startsWith('"') && value.endsWith('"')) || 
                (value.startsWith("'") && value.endsWith("'"))) {
              value = value.slice(1, -1);
            }
            flags[key] = value;
          } else {
            flags[flagContent] = true;
          }
        } else if (token.includes('=')) {
          const [key, ...valueParts] = token.split('=');
          let value = valueParts.join('=');
          // Remove quotes if present
          if ((value.startsWith('"') && value.endsWith('"')) || 
              (value.startsWith("'") && value.endsWith("'"))) {
            value = value.slice(1, -1);
          }
          flags[key] = value;
        } else {
          args.push(token);
        }
      }
      
      return { flags, args };
    }
    
    function printCellularAutomataHelp() {
      print('automata - Cellular Automaton Control System');
      print('');
      print('PERFORMANCE LIMIT: Maximum of 3 automata active at once for optimal performance.');
      print('');
      print('USAGE:');
      print('    automata <SUBCOMMAND> [OPTIONS]');
      print('    automata --menu         # Toggle automata menu');
      print('    automata --information  # Toggle automata info window');
      print('');
      print('SUBCOMMANDS:');
      print('    create                  Create a new automaton instance');
      print('    modify                  Modify an existing automaton instance');
      print('    deactivate-all          Deactivate all running automata');
      print('    list                    List all active automaton instances');
      print('    rename                  Open rename dialog for an automaton');
      print('    help                    Show this help message');
      print('');
      print('INTERFACE FLAGS:');
      print('    --menu                  Toggle automata control menu visibility');
      print('    --information           Toggle automata information window');
      print('');
      print('BASIC EXAMPLES:');
      print('    automata create --type=worm --name="My Worm"');
      print('    automata create --type=flower --x=100 --y=200');
      print('    automata modify --name="Worm 1" --scope');
      print('    automata rename "Worm 1"');
      print('    automata list');
      print('    automata deactivate-all');
      print('    automata --menu');
      print('    automata --information');
      print('');
      print('For detailed documentation, examples, and automaton types,');
      print('run: help');
      print('Then navigate to the "Cellular Automata" section.');
    }
    
    function handleCellularAutomataCreate(tokens) {
      try {
        const type = tokens.flags.type || null;
        const name = tokens.flags.name || null;
        const x = tokens.flags.x ? parseInt(tokens.flags.x) : null;
        const y = tokens.flags.y ? parseInt(tokens.flags.y) : null;
        const isRandom = tokens.flags.random || !type;
        
        if (tokens.flags.help) {
          print('USAGE: automata create [OPTIONS]');
          print('');
          print('Create a new cellular automaton instance with optional customization.');
          print('');
          print('OPTIONS:');
          print('    --type=<TYPE>          Automaton type: worm, flower, moss');
          print('    --name=<NAME>          Custom display name (use quotes for spaces)');
          print('    --x=<X>                X coordinate for spawn position');
          print('    --y=<Y>                Y coordinate for spawn position');
          print('    --random               Create random type (default if no --type)');
          print('    --help                 Show this help message');
          print('');
          print('EXAMPLES:');
          print('    automata create');
          print('    automata create --type=worm');
          print('    automata create --type=flower --name="My Flower"');
          print('    automata create --type=moss --x=100 --y=200');
          print('    automata create --name="Corner Worm" --x=10 --y=10');
          return;
        }
        
        if (type && !['worm', 'flower', 'moss'].includes(type.toLowerCase())) {
          print(`automata: invalid type '${type}'. Valid types: worm, flower, moss`);
          return;
        }
        
        // Validate coordinates if provided
        if ((x !== null && isNaN(x)) || (y !== null && isNaN(y))) {
          print('automata: coordinates must be valid numbers');
          print('Usage: automata create --x=<number> --y=<number>');
          return;
        }
        
        let automatonType;
        if (isRandom) {
          const types = ['worm', 'flower', 'moss'];
          automatonType = types[Math.floor(Math.random() * types.length)];
        } else {
          automatonType = type.toLowerCase();
        }
        
        // Spawn the automaton with coordinates and custom name if provided
        const newInstance = launchAutomaton(automatonType, x, y, name);
        if (!newInstance) {
          print('automata: failed to create automaton');
          return;
        }
        
        const displayName = newInstance.customName || `${capitalizeFirst(automatonType)} ${newInstance.number}`;
        const positionInfo = (x !== null && y !== null) ? ` at (${x}, ${y})` : '';
        print(`automata: created ${automatonType} automaton "${displayName}"${positionInfo}`);
      } catch (error) {
        console.error('Create automaton error:', error);
        print(`automata: failed to create automaton - ${error.message || 'unknown error'}`);
      }
    }
    
    function handleCellularAutomataModify(tokens) {
      const targetName = tokens.flags.name;
      const newName = tokens.flags.rename;
      const shouldScope = tokens.flags.scope;
      const shouldDeactivate = tokens.flags.deactivate;
      
      if (!targetName) {
        print('automata modify: --name=<NAME> is required');
        print('Use: automata modify --name="Automaton Name" [--rename="New Name"] [--scope] [--deactivate]');
        return;
      }
      
      // Find the automaton by name
      const automaton = findAutomatonByName(targetName);
      if (!automaton) {
        print(`automata: automaton named "${targetName}" not found`);
        return;
      }
      
      let actions = [];
      
      // Handle rename
      if (newName) {
        automaton.customName = newName;
        
        // Update the ID popup if it's currently displayed
        if (automaton.idPopup && automaton.idPopup.parentNode) {
          automaton.idPopup.textContent = newName;
        }
        
        actions.push(`renamed to "${newName}"`);
      }
      
      // Handle scope toggle
      if (shouldScope) {
        try {
          showAutomatonID(automaton);
          actions.push('ID display toggled');
        } catch (error) {
          console.error('Error toggling scope:', error);
          actions.push('scope toggle attempted');
        }
      }
      
      // Handle deactivation
      if (shouldDeactivate) {
        deactivateAutomaton(automaton.id);
        return;
      }
      
      if (actions.length === 0) {
        print('automata modify: no action specified');
        print('Available actions: --rename="New Name", --scope, --deactivate');
        return;
      }
      
      // Update UI and report success
      if (typeof updateActiveList === 'function') {
        updateActiveList();
      }
      const displayName = automaton.customName || `${capitalizeFirst(automaton.type)} ${automaton.number}`;
      print(`automata: modified "${displayName}" (${actions.join(', ')})`);
    }
    
    function handleCellularAutomataDeactivateAll(tokens) {
      const count = automatonInstances.length;
      if (count === 0) {
        print('automata: no active automata to deactivate');
        return;
      }
      
      deactivateAllAutomatons(true); // silent = true to avoid double message
      print(`automata: deactivated ${count} automaton${count === 1 ? '' : 's'}`);
    }
    
    function handleCellularAutomataList(tokens) {
      if (tokens.flags.help) {
        print('USAGE: automata list [OPTIONS]');
        print('');
        print('Display information about all currently active automaton instances.');
        print('');
        print('OPTIONS:');
        print('    --help                 Show this help message');
        print('');
        print('INFORMATION DISPLAYED:');
        print('    • Instance ID and type');
        print('    • Display name (custom or auto-generated)');
        print('    • Current status (active/scoped)');
        print('    • Creation order number');
        return;
      }
      
      if (automatonInstances.length === 0) {
        print('automata: no active automata');
        return;
      }
      
      print(`Active Automata (${automatonInstances.length}):`);
      print('');
      
      automatonInstances.forEach((instance, index) => {
        const displayName = instance.customName || `${capitalizeFirst(instance.type)} ${instance.number}`;
        const status = instance.isScoped ? '[SCOPED]' : '[ACTIVE]';
        const typeInfo = `(${instance.type})`;
        
        print(`  ${index + 1}. ${displayName} ${typeInfo} ${status}`);
        print(`     ID: ${instance.id}`);
        
        if (instance.customName) {
          print(`     Original: ${capitalizeFirst(instance.type)} ${instance.number}`);
        }
        
        if (index < automatonInstances.length - 1) {
          print('');
        }
      });
    }
    
    function handleCellularAutomataRename(tokens) {
      if (tokens.flags.help) {
        print('USAGE: automata rename "<current_name>" [OPTIONS]');
        print('');
        print('Open the rename dialog for the specified automaton.');
        print('');
        print('ARGUMENTS:');
        print('    <current_name>         The current display name of the automaton to rename');
        print('                          (use quotes if the name contains spaces)');
        print('');
        print('OPTIONS:');
        print('    --help                 Show this help message');
        print('');
        print('EXAMPLES:');
        print('    automata rename "Conway 1"');
        print('    automata rename "My Custom Automaton"');
        return;
      }
      
      if (tokens.args.length < 2) {
        print('automata: rename requires an automaton name');
        print('Usage: automata rename "<current_name>"');
        print('Try: automata rename --help');
        return;
      }
      
      const automatonName = tokens.args[1];
      const instance = findAutomatonByName(automatonName);
      
      if (!instance) {
        print(`automata: no automaton found with name "${automatonName}"`);
        print('Use "automata list" to see all active automata');
        return;
      }
      
      print(`automata: opening rename dialog for "${automatonName}"`);
      renameAutomaton(instance.id);
    }
    
    // Helper function to find automaton by name
    function findAutomatonByName(name) {
      return automatonInstances.find(instance => {
        const displayName = instance.customName || `${capitalizeFirst(instance.type)} ${instance.number}`;
        return displayName === name;
      });
    }
    
    // Helper function to toggle scope for a specific automaton
    function toggleScopeForAutomaton(automaton, silent = false) {
      // Check if this automaton is currently scoped (use the isScoped flag instead of pixel classes)
      const wasScoped = automaton.isScoped || highlightedAutomatonId === automaton.id;
      
      // Clear all existing highlights and scoped states first
      automatonInstances.forEach(instance => {
        if (instance.pixels) {
          Object.values(instance.pixels).forEach(pixel => {
            if (pixel && pixel.classList) {
              pixel.classList.remove('highlight');
            }
          });
        }
        instance.isScoped = false; // Clear scoped state for all
      });
      highlightedAutomatonId = null;
      
      if (!wasScoped) {
        // Highlight this automaton
        if (automaton.pixels) {
          Object.values(automaton.pixels).forEach(pixel => {
            if (pixel && pixel.classList) {
              pixel.classList.add('highlight');
            }
          });
        }
        automaton.isScoped = true; // Set scoped state
        highlightedAutomatonId = automaton.id;
        
        // Print feedback message only if not silent
        if (!silent && typeof print === 'function') {
          const displayName = automaton.customName || `${capitalizeFirst(automaton.type)} ${automaton.number}`;
          print(`automata: scoped "${displayName}"`);
        }
      } else {
        // Already was scoped, so we're unscoping (already cleared above)
        // Print feedback message only if not silent
        if (!silent && typeof print === 'function') {
          const displayName = automaton.customName || `${capitalizeFirst(automaton.type)} ${automaton.number}`;
          print(`automata: unscoped "${displayName}"`);
        }
      }
      
      // Update the active list to reflect selection state
      if (typeof updateActiveList === 'function') {
        updateActiveList();
      }
    }
    
    // Helper function to capitalize first letter
    function capitalizeFirst(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    function processCommand(line) {
      const cmds = line.split(';').map(l => l.trim()).filter(l => l);
      cmds.forEach(l => { 
        try {
          const parts = l.split(' ').filter(Boolean); 
          executeCommand(parts[0], parts.slice(1).join(' ')); 
        } catch (error) {
          console.error('Command execution error:', error);
          print(`Error: ${error.message || 'Command failed'}`);
        }
      });
      showPrompt();
    }

    function handleKeydown(e, input, sugg, wrap) {
      if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
        e.preventDefault();
        if (history.length) {
          historyIndex = e.key === 'ArrowUp' ? Math.max(0, historyIndex - 1) : Math.min(historyIndex + 1, history.length);
          input.value = historyIndex < history.length ? history[historyIndex] : '';
          updateOverlay(input); updateSuggestion(input, sugg); updateCursor(input, wrap);
        }
        return;
      }
      if (e.key === 'Tab') {
        e.preventDefault();
        if (sugg.textContent) {
          input.value += sugg.textContent;
          input.dispatchEvent(new Event('input'));
          sugg.textContent = '';
        }
      } else if (e.key === 'Enter') {
        e.preventDefault();
        const val = input.value;
        history.push(val); historyIndex = history.length;
        finalizePrompt(input);
        processCommand(val.trim());
      }
    }

    document.addEventListener('DOMContentLoaded', showPrompt);
    document.getElementById('terminal').addEventListener('click', () => {
  document.querySelector('.prompt-input')?.focus();
});
document.getElementById('help-modal').addEventListener('click', () => {
  document.querySelector('.modal-search')?.focus();
});


      // Data for each command's description
      const helpData = {
  welcome: {
    short: 'show welcome message',
    detail: 'Displays a friendly welcome message explaining how to use this terminal interface and encouraging exploration of custom commands.',
    examples: ['welcome'],
    expectsInput: false
  },
  help: {
    short: 'open the help window',
    detail: 'Displays this draggable, searchable help modal in the center of the page.',
    examples: ['help', 'help'],
    expectsInput: false
  },
  clear: {
    short: 'clear the terminal',
    detail: 'Erases all previous output and resets the prompt to the top of the terminal.',
    examples: ['clear', 'clear'],
    expectsInput: false
  },
  exit: {
    short: 'close the terminal',
    detail: 'Closes the terminal window with a smooth fade-out animation. This will hide the terminal interface completely.',
    examples: ['exit'],
    expectsInput: false
  },
  automata: {
    short: 'advanced cellular automaton control system',
    detail: 'Create, modify, and manage dynamic cellular automata with visual patterns. Features three distinct types (worm, flower, moss) with unique behaviors. Supports naming, scoping, real-time modification, and CLI-style flag parsing. Each automaton creates interactive pixel patterns that respond to mouse movement and follow complex algorithmic rules. Also controls interface elements. Performance limit: maximum of 3 automata active at once.',
    examples: [
      'automata create',
      'automata create --type=worm --name="My Worm"',
      'automata create --type=flower --x=100 --y=200',
      'automata modify --name="Worm 1" --scope',
      'automata rename "Worm 1"',
      'automata deactivate-all',
      'automata list',
      'automata --menu',
      'automata --information',
      'automata --help'
    ],
    expectsInput: true
  },
  ls: {
    short: 'list directory contents',
    detail: 'Lists files and folders. Flags: -a (show hidden . and ..), -l (long format).',
    examples: ['ls', 'ls -a', 'ls -l'],
    expectsInput: true
  },
  mv: {
    short: 'move (rename) file or directory',
    detail: 'Renames or moves <src> to <dest> within this virtual filesystem.',
    examples: ['mv old.txt new.txt'],
    expectsInput: true
  },
  rmdir: {
    short: 'remove empty directory',
    detail: 'Deletes an empty directory. Use `-r` to remove recursively.',
    examples: ['rmdir dir', 'rmdir -r dir'],
    expectsInput: true
  },
  rm: {
    short: 'remove file or directory',
    detail: 'Deletes a file. Use `-r` to delete directories and their contents.',
    examples: ['rm file.txt', 'rm -r folder'],
    expectsInput: true
  },
  touch: {
    short: 'create empty file or update timestamp',
    detail: 'Creates a new empty file or updates the timestamp of an existing file.',
    examples: ['touch newfile.txt'],
    expectsInput: true
  },
  date: {
    short: 'show current date and time',
    detail: 'Displays the current date and time.',
    examples: ['date'],
    expectsInput: false
  },
  grep: {
    short: 'search text in files',
    detail: 'Searches for <pattern> in a file and prints matching lines.',
    examples: ['grep TODO notes.txt'],
    expectsInput: true
  },
  cd: {
    short: 'change directory',
    detail: 'Navigate into a different folder. Supports absolute and relative paths, including `~` for your home directory.',
    examples: ['cd projects', 'cd ~/Documents'],
    expectsInput: true
  },
  pwd: {
    short: 'print working directory',
    detail: 'Displays the full path of the current directory in which the terminal is operating.',
    examples: ['pwd', 'pwd'],
    expectsInput: false
  },
  cat: {
    short: 'show file contents',
    detail: 'Outputs the text contents of a file directly in the terminal window.',
    examples: ['cat README.md', 'cat /etc/config.json'],
    expectsInput: true
  },
  mkdir: {
    short: 'make directory',
    detail: 'Creates a new folder in the current directory with the given name.',
    examples: ['mkdir new_folder', 'mkdir "My Documents"'],
    expectsInput: true
  },
  theme: {
    short: 'toggle themes with flags',
    detail: 'Controls both terminal and website themes. Requires flags: --terminal for terminal color scheme, --webpage for website light/dark mode, or specific terminal themes with --light, --blue, --dark.',
    examples: ['theme --terminal', 'theme --webpage', 'theme --light', 'theme --blue', 'theme --dark'],
    expectsInput: true
  },
    keyboard: {
    short: 'toggle on-screen keyboard',
    detail: 'Shows or hides the floating keyboard panel.',
    examples: ['keyboard'],
    expectsInput: false
  },
  vim: {
    short: 'open vim text editor',
    detail: 'Opens a vim-like text editor in a new window with basic editing capabilities.',
    examples: ['vim filename.txt', 'vim notes.md'],
    expectsInput: true
  },
  download: {
    short: 'download current file',
    detail: 'Downloads the currently open file in the vim editor to your computer.',
    examples: ['download', 'download myfile.txt'],
    expectsInput: false
  },
  goto: {
    short: 'navigate to page or external URL',
    detail: 'Navigate to different sections of the website or open external links. Accepts exactly one destination: home, research, experience, education, github, or linkedin.',
    examples: ['goto home', 'goto research', 'goto github'],
    expectsInput: true
  }
};


    // Show the modal and populate its body
    function showHelpModal() {
  const modal = document.getElementById('help-modal');
  const body  = modal.querySelector('.modal-body');
  
  // Add the tutorial link at the top
  body.innerHTML = `
    <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(74, 158, 255, 0.1); border-radius: 8px; border: 1px solid rgba(74, 158, 255, 0.3);">
      <strong>New to Linux? <a href="https://www.youtube.com/watch?v=YHFzr-akOas&ab_channel=ProgrammingKnowledge" target="_blank" rel="noopener noreferrer" style="color: #4A9EFF; text-decoration: underline;">Watch this tutorial</a></strong>
    </div>
    
    <div style="margin-bottom: 20px;">
      <h3 style="color: #4A9EFF; margin-bottom: 10px; font-size: 18px;">📋 Custom Commands</h3>
      ${Object.entries(helpData).filter(([cmd, info]) => 
        ['welcome', 'help', 'automata', 'theme', 'keyboard', 'download', 'goto'].includes(cmd)
      ).map(([cmd, info]) => `
        <div class="cmd-item">
          <div class="cmd-header">
            <span class="cmd-name"><strong>${cmd}</strong></span>
            <span class="cmd-short">${info.short}</span>
            <span class="toggle-arrow">▾</span>
          </div>
          <div class="cmd-detail">
            <p>${info.detail}</p>
            <ul>${info.examples.map(e => `<li><code>${e}</code></li>`).join('')}</ul>
          </div>
        </div>
      `).join('')}
    </div>
    
    <div>
      <h3 style="color: #4A9EFF; margin-bottom: 10px; font-size: 18px;">🐧 Linux Commands</h3>
      ${Object.entries(helpData).filter(([cmd, info]) => 
        !['welcome', 'help', 'automata', 'theme', 'keyboard', 'download', 'goto'].includes(cmd)
      ).map(([cmd, info]) => `
        <div class="cmd-item">
          <div class="cmd-header">
            <span class="cmd-name"><strong>${cmd}</strong></span>
            <span class="cmd-short">${info.short}</span>
            <span class="toggle-arrow">▾</span>
          </div>
          <div class="cmd-detail">
            <p>${info.detail}</p>
            <ul>${info.examples.map(e => `<li><code>${e}</code></li>`).join('')}</ul>
          </div>
        </div>
      `).join('')}
    </div>
  `;

  // wire up expand/collapse
body.querySelectorAll('.cmd-header').forEach(h => {
  h.addEventListener('click', () => {
    // find the detail panel and the arrow for this header
    const detail = h.nextElementSibling;
    const arrow  = h.querySelector('.toggle-arrow');
    // toggle open/closed states
    detail.classList.toggle('open');
    arrow .classList.toggle('open');
  });
});  // ← closes the forEach ONLY

// finally, display the modal
modal.style.display = 'block';

bringToFront(modal);

}


    document.querySelector('#help-modal .close-btn')
  .addEventListener('click', () => {
    // hide the help window
    document.getElementById('help-modal').style.display = 'none';
    // put the cursor back in the prompt
    const promptInput = document.querySelector('.prompt-input');
    if (promptInput) promptInput.focus();
  });

    // Drag-to-move support
    (function() {
      const modal  = document.getElementById('help-modal');
      const header = modal.querySelector('.modal-header');
      let dragging = false, offsetX, offsetY;

      header.addEventListener('mousedown', e => {
        dragging = true;
        offsetX = e.clientX - modal.offsetLeft;
        offsetY = e.clientY - modal.offsetTop;
      });
      document.addEventListener('mousemove', e => {
        if (dragging) {
          modal.style.left = (e.clientX - offsetX) + 'px';
          modal.style.top  = (e.clientY - offsetY) + 'px';
        }
      });
      document.addEventListener('mouseup', () => { dragging = false; });
    })();

     // Live-search filter: hide/show entire command items
 document.querySelector('#help-modal .modal-search')
   .addEventListener('input', e => {
     const filter = e.target.value.toLowerCase();
     document.querySelectorAll('#help-modal .cmd-item')
       .forEach(item => {
         // include name, short & detail in the match
         const text = item.textContent.toLowerCase();
         item.style.display = text.includes(filter) ? '' : 'none';
       });
   });

   // ------- Typewriter with per-char key lighting -------
const Typewriter = (() => {
  let busy = false;

  const charToCode = (ch) => {
    if (/^[a-z]$/i.test(ch)) return 'Key' + ch.toUpperCase();
    if (/^\d$/.test(ch))     return 'Digit' + ch;
    const map = {
      ' ': 'Space', '-': 'Minus', '=': 'Equal',
      '[': 'BracketLeft', ']': 'BracketRight', '\\': 'Backslash',
      ';': 'Semicolon', "'": 'Quote',
      ',': 'Comma', '.': 'Period', '/': 'Slash'
    };
    return map[ch] || null;
  };

  const isKeyboardVisible = () =>
    !document.getElementById('keyboard-panel').classList.contains('hidden');

  const flashKeyByCode = (code, dur = 120) => {
    if (!code) return;
    const el = document.querySelector(`.key[data-key="${code}"]`);
    if (!el) return;
    el.classList.add('active','pressed');
    setTimeout(() => el.classList.remove('active','pressed'), dur);
  };

  const flashChar = (ch) => {
    if (!isKeyboardVisible()) return;
    flashKeyByCode(charToCode(ch));
  };

  const pressEnter = () => {
    if (isKeyboardVisible()) flashKeyByCode('Enter', ENTER_FLASH_MS);
    
    // Find the currently active prompt input (last one)
    const allPromptInputs = document.querySelectorAll('.prompt-input');
    const input = allPromptInputs[allPromptInputs.length - 1];
    
    if (!input) {
      console.warn('No prompt input found when pressing Enter');
      return;
    }
    
    // Ensure input has focus
    input.focus();
    
    // Add a small delay to ensure focus is set
    setTimeout(() => {
      const ev = new KeyboardEvent('keydown', { 
        key: 'Enter', 
        keyCode: 13, 
        which: 13,
        bubbles: true 
      });
      input.dispatchEvent(ev);
    }, 10);
  };

  const type = (text, { delay = 80, highlight = true } = {}) => new Promise((resolve) => {
    if (busy) return resolve();
    busy = true;

    // Find the last prompt input (the active one)
    let allPromptInputs = document.querySelectorAll('.prompt-input');
    let input = allPromptInputs[allPromptInputs.length - 1];
    
    if (!input) { 
      showPrompt(); 
      allPromptInputs = document.querySelectorAll('.prompt-input');
      input = allPromptInputs[allPromptInputs.length - 1];
    }

    if (!input) {
      console.error('Could not find or create prompt input');
      busy = false;
      resolve();
      return;
    }

    input.value = '';
    input.dispatchEvent(new Event('input'));
    input.focus(); // Ensure input has focus

    const chars = [...text];
    let i = 0;

    const step = () => {
      if (i < chars.length) {
        const ch = chars[i++];
        input.value += ch;
        input.dispatchEvent(new Event('input'));
        if (highlight) flashChar(ch);
        setTimeout(step, delay);
      } else {
        pressEnter();
        busy = false;
        resolve();
      }
    };
    step();
  });

  return { type, isBusy: () => busy };
})();

// Back-compat wrapper
function autoTypeAndRun(command, opts) {
  return Typewriter.type(command, opts || {});
}

// Vim Editor functionality
let currentVimFile = '';
let vimFileContent = '';
let vimMode = 'INSERT'; // 'INSERT', 'NORMAL', 'COMMAND'
let vimCommandBuffer = '';
let vimFileModified = false; // Track if file has unsaved changes

function openVimEditor(filename) {
  currentVimFile = filename;
  vimFileModified = false; // Reset modified flag when opening
  const vimEditor = document.getElementById('vim-editor');
  const filenameEl = vimEditor.querySelector('.vim-filename');
  const tabEl = vimEditor.querySelector('.vim-tab');
  const textarea = vimEditor.querySelector('.vim-textarea');
  
  // Set filename in header and tab
  filenameEl.textContent = filename;
  tabEl.textContent = filename;
  
  // Load existing file content if it exists
  const node = getNode(resolvePath(filename));
  if (node && node.type === 'file' && node.content) {
    vimFileContent = node.content;
    textarea.value = node.content;
    vimFileModified = false; // File loaded from disk, so not modified
  } else {
    vimFileContent = '';
    textarea.value = '';
    vimFileModified = false; // New file, not modified yet
  }
  
  // Start in INSERT mode
  setVimMode('INSERT');
  
  // Show vim editor
  vimEditor.style.display = 'block';
  updateVimStatusInfo();
  textarea.focus();
  bringToFront(vimEditor);
}

function setVimMode(mode) {
  vimMode = mode;
  const modeEl = document.querySelector('#vim-editor .vim-mode');
  const textarea = document.querySelector('#vim-editor .vim-textarea');
  
  if (mode === 'INSERT') {
    modeEl.textContent = '-- INSERT --';
    modeEl.style.backgroundColor = '#005f00';
    modeEl.style.borderColor = '#007f00';
    modeEl.style.color = '#ffffff';
    textarea.style.backgroundColor = '#2d1b69';
    textarea.readOnly = false;
  } else if (mode === 'NORMAL') {
    modeEl.textContent = '-- NORMAL --';
    modeEl.style.backgroundColor = '#d4a017';
    modeEl.style.borderColor = '#ffcc00';
    modeEl.style.color = '#000000';
    textarea.style.backgroundColor = '#2a1560';
    textarea.readOnly = true;
  } else if (mode === 'COMMAND') {
    modeEl.textContent = ':' + vimCommandBuffer;
    modeEl.style.backgroundColor = '#0066cc';
    modeEl.style.borderColor = '#0088ff';
    modeEl.style.color = '#ffffff';
    textarea.readOnly = true;
  }
}

function executeVimCommand(cmd) {
  cmd = cmd.trim();
  
  if (cmd === 'q') {
    // Quit without saving - check for unsaved changes
    if (vimFileModified) {
      showVimMessage('No write since last change (add ! to override)');
      setVimMode('NORMAL');
      return;
    }
    closeVimEditor(); // Quit immediately like real vim
  } else if (cmd === 'w') {
    // Save file
    const textarea = document.querySelector('#vim-editor .vim-textarea');
    const lineCount = textarea.value.split('\n').length;
    const charCount = textarea.value.length;
    
    saveVimFile();
    vimFileModified = false;
    setVimMode('NORMAL');
    showVimMessage(`"${currentVimFile}" ${lineCount}L, ${charCount}C written`);
  } else if (cmd === 'wq') {
    // Save and quit
    const textarea = document.querySelector('#vim-editor .vim-textarea');
    const lineCount = textarea.value.split('\n').length;
    const charCount = textarea.value.length;
    
    saveVimFile();
    vimFileModified = false;
    showVimMessage(`"${currentVimFile}" ${lineCount}L, ${charCount}C written`);
    setTimeout(() => closeVimEditor(), 2500); // Wait for message to show
  } else if (cmd === 'x') {
    // Save and quit (same as :wq)
    const textarea = document.querySelector('#vim-editor .vim-textarea');
    const lineCount = textarea.value.split('\n').length;
    const charCount = textarea.value.length;
    
    saveVimFile();
    vimFileModified = false;
    showVimMessage(`"${currentVimFile}" ${lineCount}L, ${charCount}C written`);
    setTimeout(() => closeVimEditor(), 2500); // Wait for message to show
  } else if (cmd === 'q!') {
    // Force quit without saving - discard changes
    vimFileModified = false;
    closeVimEditor(); // Quit immediately like real vim
  } else if (cmd === 'help' || cmd === 'h') {
    // Show basic help
    showVimMessage('Basic commands: :w (save), :q (quit), :wq (save & quit), :q! (force quit), ESC (normal mode), i (insert mode)');
    setVimMode('NORMAL');
  } else if (cmd.startsWith('w ')) {
    // Save as (write to specific file)
    const filename = cmd.substring(2).trim();
    if (filename) {
      const textarea = document.querySelector('#vim-editor .vim-textarea');
      const lineCount = textarea.value.split('\n').length;
      const charCount = textarea.value.length;
      
      currentVimFile = filename;
      saveVimFile();
      vimFileModified = false;
      showVimMessage(`"${filename}" ${lineCount}L, ${charCount}C written`);
      setVimMode('NORMAL');
    } else {
      showVimMessage('E471: Argument required');
      setVimMode('NORMAL');
    }
  } else if (cmd === 'wa') {
    // Write all (save current file)
    const textarea = document.querySelector('#vim-editor .vim-textarea');
    const lineCount = textarea.value.split('\n').length;
    const charCount = textarea.value.length;
    
    saveVimFile();
    vimFileModified = false;
    showVimMessage(`"${currentVimFile}" ${lineCount}L, ${charCount}C written`);
    setVimMode('NORMAL');
  } else if (cmd === 'qa') {
    // Quit all (close vim)
    if (vimFileModified) {
      showVimMessage('No write since last change (add ! to override)');
      setVimMode('NORMAL');
      return;
    }
    closeVimEditor();
  } else if (cmd === 'qa!') {
    // Force quit all
    vimFileModified = false;
    closeVimEditor();
  } else if (cmd === 'wqa') {
    // Write and quit all
    const textarea = document.querySelector('#vim-editor .vim-textarea');
    const lineCount = textarea.value.split('\n').length;
    const charCount = textarea.value.length;
    
    saveVimFile();
    vimFileModified = false;
    showVimMessage(`"${currentVimFile}" ${lineCount}L, ${charCount}C written`);
    setTimeout(() => closeVimEditor(), 2500);
  } else if (cmd === 'xa') {
    // Write and quit all (same as wqa)
    const textarea = document.querySelector('#vim-editor .vim-textarea');
    const lineCount = textarea.value.split('\n').length;
    const charCount = textarea.value.length;
    
    saveVimFile();
    vimFileModified = false;
    showVimMessage(`"${currentVimFile}" ${lineCount}L, ${charCount}C written`);
    setTimeout(() => closeVimEditor(), 2500);
  } else if (cmd === 'e') {
    // Edit current file (reload)
    showVimMessage('Command not supported in this simplified vim');
    setVimMode('NORMAL');
  } else if (cmd.startsWith('e ')) {
    // Edit different file
    showVimMessage('Command not supported in this simplified vim');
    setVimMode('NORMAL');
  } else if (cmd.match(/^\d+$/)) {
    // Go to line number
    showVimMessage('Line navigation not supported in this simplified vim');
    setVimMode('NORMAL');
  } else if (cmd.startsWith('/') || cmd.startsWith('?')) {
    // Search
    showVimMessage('Search not supported in this simplified vim');
    setVimMode('NORMAL');
  } else if (cmd === 'set' || cmd.startsWith('set ')) {
    // Settings
    showVimMessage('Settings not supported in this simplified vim');
    setVimMode('NORMAL');
  } else if (cmd === '' || cmd === ' ') {
    // Empty command
    setVimMode('NORMAL');
  } else {
    // Unknown command
    showVimMessage(`E492: Not an editor command: ${cmd}`);
    setVimMode('NORMAL');
  }
  
  vimCommandBuffer = '';
}

function closeVimEditor() {
  const vimEditor = document.getElementById('vim-editor');
  vimEditor.style.display = 'none';
  
  // Reset vim state
  vimFileModified = false;
  vimCommandBuffer = '';
  setVimMode('INSERT');
  
  // Focus back to terminal
  const promptInput = document.querySelector('.prompt-input');
  if (promptInput) promptInput.focus();
}

function updateVimStatusInfo() {
  const infoEl = document.querySelector('#vim-editor .vim-info');
  const textarea = document.querySelector('#vim-editor .vim-textarea');
  if (!infoEl || !textarea) return;
  
  // Don't update if there's an active message showing
  const overlay = document.querySelector('#vim-message-overlay');
  if (overlay && overlay.classList.contains('show')) {
    return;
  }
  
  const lines = textarea.value.split('\n');
  const cursorPos = textarea.selectionStart;
  const textBeforeCursor = textarea.value.substring(0, cursorPos);
  const currentLine = textBeforeCursor.split('\n').length;
  const currentCol = textBeforeCursor.split('\n').pop().length + 1;
  
  const modifiedIndicator = vimFileModified ? ' [+]' : '';
  infoEl.textContent = `Line ${currentLine}, Col ${currentCol} | UTF-8${modifiedIndicator}`;
}

function showVimMessage(message) {
  const overlay = document.querySelector('#vim-message-overlay');
  if (!overlay) {
    console.log('Could not find vim message overlay');
    return;
  }
  
  console.log('Showing vim message:', message); // Debug log
  
  // Clear any existing timeout
  if (window.vimMessageTimeout) {
    clearTimeout(window.vimMessageTimeout);
  }
  
  // Show the message
  overlay.textContent = message;
  overlay.classList.add('show');
  
  // Hide message after 2 seconds
  window.vimMessageTimeout = setTimeout(() => {
    overlay.classList.remove('show');
  }, 2000);
}

function getCurrentVimFilename() {
  return currentVimFile;
}

function downloadVimFile(filename) {
  const textarea = document.querySelector('#vim-editor .vim-textarea');
  const content = textarea ? textarea.value : vimFileContent;
  
  if (!content.trim()) {
    print('download: file is empty');
    return;
  }
  
  // Create download
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  
  print(`Downloaded: ${filename}`);
}

function saveVimFile() {
  if (!currentVimFile) return;
  
  const textarea = document.querySelector('#vim-editor .vim-textarea');
  const content = textarea.value;
  
  // Update file in virtual filesystem
  const pathArr = resolvePath(currentVimFile);
  const parentArr = pathArr.slice(0, -1);
  const filename = pathArr.slice(-1)[0];
  const parent = getNode(parentArr);
  
  if (parent && parent.type === 'dir') {
    parent.children[filename] = {
      type: 'file',
      content: content,
      author: 'user',
      mtime: new Date()
    };
    vimFileContent = content;
  }
}

// Position keyboard below terminal with appropriate scaling
function positionKeyboardBelowTerminal(panel) {
  const terminal = document.getElementById('terminal-window');
  const keyboard = document.getElementById('keyboard');
  
  if (!terminal || !keyboard) return;
  
  // Get terminal position and dimensions
  const terminalRect = terminal.getBoundingClientRect();
  const terminalWidth = terminalRect.width;
  
  // Calculate appropriate scale based on terminal width
  // Use proportional scaling (0.8 for 33.75vw baseline) but cap at 0.65 maximum
  const baseTerminalWidth = window.innerWidth * 0.3375; // 33.75vw in pixels
  const scaleRatio = terminalWidth / baseTerminalWidth;
  const proportionalScale = 0.8 * scaleRatio;
  
  // Cap the scale at 0.65 maximum
  const appropriateScale = Math.min(proportionalScale, 0.65);
  
  // Get keyboard base dimensions
  const baseWidth = parseFloat(keyboard.dataset.baseW);
  const baseHeight = parseFloat(keyboard.dataset.baseH);
  
  // Apply scale
  keyboard.style.transform = `scale(${appropriateScale})`;
  
  // Calculate scaled dimensions and position
  const scaledWidth = baseWidth * appropriateScale;
  const scaledHeight = baseHeight * appropriateScale;
  const baseGapSize = 10;
  const scaledGap = baseGapSize * appropriateScale;
  
  // Update panel size
  panel.style.width = (scaledWidth + scaledGap * 2) + 'px';
  panel.style.height = (scaledHeight + scaledGap * 2) + 'px';
  
  // Position below terminal with gap, centered horizontally
  const gap = 20; // 20px gap between terminal and keyboard
  const keyboardTop = terminalRect.bottom + window.scrollY + gap;
  
  // Center keyboard horizontally with terminal
  const terminalCenterX = terminalRect.left + (terminalRect.width / 2);
  const keyboardCenterX = terminalCenterX - (scaledWidth + scaledGap * 2) / 2;
  const keyboardLeft = keyboardCenterX + window.scrollX;
  
  panel.style.top = keyboardTop + 'px';
  panel.style.left = keyboardLeft + 'px';
  panel.style.bottom = 'auto'; // Clear any bottom positioning
}


document.addEventListener('DOMContentLoaded', () => {
  const container = document.querySelector('.cli-buttons');
  const helpBtn   = container.querySelector('.help-btn');
  const clearBtn  = container.querySelector('.clear-btn');
  const kbBtn     = container.querySelector('.keyboard-toggle-btn');
  const themeBtn  = container.querySelector('.theme-btn');

  // open/focus help
  helpBtn.addEventListener('click', () => {
    const commandLength = 'help'.length;
    const delay = Math.max(25, Math.min(100, 500 / commandLength));
    autoTypeAndRun('help', { delay });
  });

  // clear terminal
  clearBtn.addEventListener('click', () => {
    const commandLength = 'clear'.length;
    const delay = Math.max(25, Math.min(100, 500 / commandLength));
    autoTypeAndRun('clear', { delay });
  });

  // toggle keyboard via command (so it also logs history + lights keys)
  kbBtn.addEventListener('click', () => {
    const commandLength = 'keyboard'.length;
    const delay = Math.max(25, Math.min(100, 500 / commandLength));
    autoTypeAndRun('keyboard', { delay });
  });

  // cycle theme
  themeBtn.addEventListener('click', () => {
    const commandLength = 'theme --terminal'.length;
    const delay = Math.max(25, Math.min(100, 500 / commandLength));
    autoTypeAndRun('theme --terminal', { delay });
  });

  updateIndicator();
  
  // Helper function to check if terminal is open and auto-type command
  function runCommandIfTerminalOpen(command, callback) {
    const terminalWindow = document.getElementById('terminal-window');
    const isTerminalOpen = terminalWindow.style.display !== 'none' && 
                          !terminalWindow.classList.contains('hide');
    
    if (isTerminalOpen) {
      // Calculate delay for 0.5-second total duration
      const commandLength = command.length;
      const delay = Math.max(25, Math.min(100, 500 / commandLength));
      
      // Auto-type the command and execute callback after typing completes
      autoTypeAndRun(command, { delay }).then(() => {
        if (callback) callback();
      });
      return true; // Command was auto-typed
    }
    return false; // Terminal not open, proceed with normal action
  }
  
  // Initialize modal draggable functionality
  makeModalDraggable();

  // Website Navigation System
  function initializeWebsiteNavigation() {
    const menuLinks = document.querySelectorAll('[data-page]');
    const contentContainer = document.querySelector('.website-content-container');
    
    menuLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const targetPage = e.target.getAttribute('data-page');
        navigateToPage(targetPage);
      });
    });
    
    // Handle special links
    const terminalLink = document.querySelector('.terminal-link');
    const automataLink = document.querySelector('.automata-link');
    
    if (terminalLink) {
      terminalLink.addEventListener('click', (e) => {
        e.preventDefault();
        // Animate terminal button
        const terminalBtn = document.querySelector('.terminal-toggle-btn');
        if (terminalBtn) {
          // Enhanced flash animation
          terminalBtn.style.transition = 'all 0.2s ease';
          terminalBtn.style.transform = 'scale(1.2)';
          terminalBtn.style.background = '#005fef';
          terminalBtn.style.boxShadow = '0 0 20px #005fef';
          
          setTimeout(() => {
            terminalBtn.style.transform = 'scale(1.1)';
          }, 100);
          
          setTimeout(() => {
            terminalBtn.style.transform = 'scale(1)';
            terminalBtn.style.background = '';
            terminalBtn.style.boxShadow = '';
            terminalBtn.style.transition = '';
          }, 300);
          
          // Always trigger terminal toggle
          setTimeout(() => {
            const terminalWindow = document.getElementById('terminal-window');
            if (terminalWindow.style.display === 'none' || terminalWindow.style.display === '') {
              // Open terminal
              terminalWindow.style.display = 'flex';
              terminalWindow.classList.remove('hide');
              terminalWindow.classList.add('show');
              // Reset to default position and size when opening
              terminalWindow.style.top = '35vh';
              terminalWindow.style.left = '5vw';
              terminalWindow.style.width = '33.75vw';
              terminalWindow.style.height = '35vh';
              terminalWindow.style.minHeight = '120px';
              terminalWindow.style.maxHeight = 'calc(100vh - 35vh - 80px)';
              
              // Clear terminal history when reopening
              clearTerminal();
              showPrompt();
              
              // Focus the terminal input
              setTimeout(() => {
                const terminalInput = document.querySelector('.prompt-input');
                if (terminalInput) {
                  terminalInput.focus();
                  // Force cursor position update and ensure cursor is at end
                  terminalInput.setSelectionRange(terminalInput.value.length, terminalInput.value.length);
                  const wrapper = terminalInput.parentElement;
                  if (wrapper) {
                    updateCursor(terminalInput, wrapper);
                  }
                  
                  // Show keyboard panel
                  const keyboardPanel = document.getElementById('keyboard-panel');
                  if (keyboardPanel.classList.contains('hidden')) {
                    positionKeyboardBelowTerminal(keyboardPanel);
                    keyboardPanel.classList.remove('hidden');
                    bringToFront(keyboardPanel);
                  }
                  
                  // Auto-type welcome command
                  setTimeout(() => {
                    const commandLength = 'welcome'.length;
                    const delay = Math.max(25, Math.min(100, 500 / commandLength));
                    autoTypeAndRun('welcome', { delay });
                  }, 500); // Give a moment for everything to settle
                }
              }, 300); // Wait for animation to complete
            }
          }, 150);
        }
      });
    }
    
    if (automataLink) {
      automataLink.addEventListener('click', (e) => {
        e.preventDefault();
        // Animate automata button
        const automataBtn = document.querySelector('.cellular-automaton-btn');
        if (automataBtn) {
          // Enhanced flash animation
          automataBtn.style.transition = 'all 0.2s ease';
          automataBtn.style.transform = 'scale(1.2)';
          automataBtn.style.background = '#005fef';
          automataBtn.style.boxShadow = '0 0 20px #005fef';
          
          setTimeout(() => {
            automataBtn.style.transform = 'scale(1.1)';
          }, 100);
          
          setTimeout(() => {
            automataBtn.style.transform = 'scale(1)';
            automataBtn.style.background = '';
            automataBtn.style.boxShadow = '';
            automataBtn.style.transition = '';
          }, 300);
          
          // Always trigger automata menu toggle
          setTimeout(() => {
            const caMenu = document.getElementById('ca-menu');
            if (caMenu) {
              if (caMenu.style.display !== 'flex') {
                // Open automata menu
                caMenu.style.display = 'flex';
              }
            }
          }, 150);
        }
      });
    }
    
    function navigateToPage(pageName) {
      const currentPage = document.querySelector('.website-page.active');
      const targetPage = document.getElementById(`${pageName}-page`);
      
      if (!targetPage || currentPage === targetPage) return;
      
      // Start fade out
      contentContainer.classList.add('fade-out');
      
      setTimeout(() => {
        // Hide current page and show target page
        if (currentPage) currentPage.classList.remove('active');
        targetPage.classList.add('active');
        
        // Fade back in
        contentContainer.classList.remove('fade-out');
      }, 250); // Half of the transition duration
    }
  }
  
  // Initialize website navigation
  initializeWebsiteNavigation();

  // Function to force close all terminal-related windows
  function forceCloseAllTerminalWindows() {
    // Check if vim is open and auto-save if needed
    const vimEditor = document.getElementById('vim-editor');
    if (vimEditor.style.display !== 'none') {
      // Auto-save vim file before closing
      saveVimFile();
      // Close vim editor
      closeVimEditor();
    }
    
    // Close help modal
    const helpModal = document.getElementById('help-modal');
    if (helpModal.style.display === 'block') {
      helpModal.style.display = 'none';
    }
    
    // Close keyboard panel
    const keyboardPanel = document.getElementById('keyboard-panel');
    if (!keyboardPanel.classList.contains('hidden')) {
      keyboardPanel.classList.add('hidden');
    }
    
    // Clear any vim message overlays
    const messageOverlay = document.querySelector('.vim-message-overlay');
    if (messageOverlay) {
      messageOverlay.classList.remove('show');
    }
  }

  // Terminal toggle button
  const terminalToggleBtn = document.querySelector('.terminal-toggle-btn');
  const terminalWindow = document.getElementById('terminal-window');
  let animationInProgress = false;

  terminalToggleBtn.addEventListener('click', () => {
    if (animationInProgress) return; // Prevent multiple clicks during animation
    
    // Check if terminal is currently visible - handle both inline styles and computed styles
    const computedDisplay = window.getComputedStyle(terminalWindow).display;
    const isTerminalOpen = (terminalWindow.style.display === 'flex' || 
                           (terminalWindow.style.display === '' && computedDisplay === 'flex')) && 
                          !terminalWindow.classList.contains('hide');
    
    if (isTerminalOpen) {
      // Terminal is open, so close it
      animationInProgress = true;
      
      // Force close all terminal-related windows first
      forceCloseAllTerminalWindows();
      
      const commandLength = 'exit'.length;
      const delay = Math.max(25, Math.min(100, 500 / commandLength));
      autoTypeAndRun('exit', { delay });
      animationInProgress = false;
    } else {
      // Terminal is closed, so open it (without keyboard or welcome)
      animationInProgress = true;
      
      // Show terminal with animation
      terminalWindow.style.display = 'flex';
      // Reset to default position and size when opening
      terminalWindow.style.top = '10vh';
      terminalWindow.style.left = '5vw';
      terminalWindow.style.width = '33.75vw';
      terminalWindow.style.height = '35vh';
      terminalWindow.style.minHeight = '120px';
      terminalWindow.style.maxHeight = 'calc(100vh - 10vh - 80px)';
      
      // Clear terminal history when reopening
      clearTerminal();
      showPrompt();
      
      // Remove any existing animation classes
      terminalWindow.classList.remove('hide');
      // Trigger show animation
      requestAnimationFrame(() => {
        terminalWindow.classList.add('show');
      });
      
      // Focus the input after animation and fix cursor position
      setTimeout(() => {
        const input = document.querySelector('.prompt-input');
        if (input) {
          input.focus();
          // Force cursor position update
          const wrap = input.parentElement;
          if (wrap) {
            updateCursor(input, wrap);
          }
        }
        
        animationInProgress = false;
      }, 300);
    }
  });

  // Theme toggle functionality
  const themeToggleBtn = document.querySelector('.theme-toggle-btn');
  const body = document.body;
  let isDarkMode = true; // Start in dark mode
  
  // Initialize tooltip for dark mode (shows "Light Mode" to indicate next state)
  themeToggleBtn.setAttribute('data-tip', 'Light Mode');
  
  themeToggleBtn.addEventListener('click', () => {
    // Normal theme toggle behavior
    isDarkMode = !isDarkMode;
    
    if (isDarkMode) {
      // Switch to dark mode
      body.classList.remove('light-mode');
      themeToggleBtn.classList.remove('light-mode');
      // Show "Light Mode" tooltip (next state to go to)
      themeToggleBtn.setAttribute('data-tip', 'Light Mode');
    } else {
      // Switch to light mode
      body.classList.add('light-mode');
      themeToggleBtn.classList.add('light-mode');
      // Show "Dark Mode" tooltip (next state to go to)
      themeToggleBtn.setAttribute('data-tip', 'Dark Mode');
    }
  });

  // Worm Cellular Automaton (evolved from GridAutomaton)
  class WormAutomaton {
    constructor() {
      this.cellSize = 6; // Smaller pixels
      this.gridWidth = Math.floor(window.innerWidth / this.cellSize);
      this.gridHeight = Math.floor(window.innerHeight / this.cellSize);
      this.grid = [];
      this.pixels = {}; // Store DOM elements by grid position
      this.colors = ['blue', 'white'];
      this.colorValues = {
        'blue': '#005fef',
        'white': '#ffffff'
      };
      this.isActive = false;
      this.isDestroying = false; // Prevent multiple destruction calls
      this.animationId = null;
      this.mouseX = 0;
      this.mouseY = 0;
      this.cursorRadius = 4; // Grid cells around cursor
      this.generation = 0;
      this.lastUpdate = 0;
      this.updateInterval = 250; // 3x faster (was 800ms)
      
      // Swarm movement properties
      this.swarmCenter = { x: 0, y: 0 }; // Virtual center of the swarm
      this.swarmTarget = { x: 0, y: 0 }; // Where the swarm wants to go
      this.swarmVelocity = { x: 0, y: 0 }; // Current movement direction
      this.swarmCuriosity = 0.04; // Less frequent direction changes for more stable movement
      this.swarmSpeed = 0.8; // Moderate movement speed
      this.lastSwarmUpdate = 0;
      this.swarmUpdateInterval = 100; // Update every 100ms for stable movement
      this.isSwarmActive = true; // Enable swarm behavior by default
      this.isResting = false; // Sometimes the insect pauses
      this.restDuration = 0;
      this.center = { x: 0, y: 0 }; // Track center for collision avoidance // How long to rest
      this.creatureType = 'worm'; // Track what kind of creature this is
      
      // Worm evolution properties
      this.isEvolvingWorm = false;
      this.evolutionStage = 0; // 0=circle, 1=oval, 2=short worm, 3=medium worm, 4=long worm, 5=complete
      this.evolutionTimer = 0;
      this.wormCenter = { x: 0, y: 0 };
      this.wormDirection = 0; // Current direction (0=right, 1=down, 2=left, 3=up)
      this.wormBody = []; // Array of worm segments {x, y, color}
      this.evolutionInterval = 300; // Much faster - 300ms between evolution stages
    }
    
    spawn(spawnX = null, spawnY = null) {
      console.log('WormAutomaton spawn called with:', { spawnX, spawnY });
      if (this.isActive) {
        console.log('WormAutomaton already active, returning');
        return; // Only one at a time
      }
      
      this.isActive = true;
      this.initializeGrid();
      
      // Use provided coordinates or generate random ones within central safe area
      if (spawnX !== null && spawnY !== null) {
        // Use provided coordinates if given
        console.log('Using provided coordinates:', spawnX, spawnY);
        const centerX = spawnX;
        const centerY = spawnY;
        this.center = { x: centerX, y: centerY };
        this.swarmCenter = { x: centerX, y: centerY };
      } else {
        // Define safe central region in pixels (away from browser edges)
        const edgeMarginPx = 100; // 100px margin from all edges
        const safeLeft = edgeMarginPx;
        const safeRight = window.innerWidth - edgeMarginPx;
        const safeTop = edgeMarginPx;
        const safeBottom = window.innerHeight - edgeMarginPx;
        
        // Generate random position within safe central area (in pixels)
        const randomX = safeLeft + Math.random() * (safeRight - safeLeft);
        const randomY = safeTop + Math.random() * (safeBottom - safeTop);
        
        // Convert pixel coordinates to grid coordinates
        const centerX = Math.floor(randomX / this.cellSize);
        const centerY = Math.floor(randomY / this.cellSize);
        
        // Ensure coordinates are within grid bounds
        const clampedX = Math.max(0, Math.min(this.gridWidth - 1, centerX));
        const clampedY = Math.max(0, Math.min(this.gridHeight - 1, centerY));
        
        this.center = { x: clampedX, y: clampedY };
        this.swarmCenter = { x: clampedX, y: clampedY };
      }
      
      // Initialize worm behavior (disabled during evolution)
      this.swarmTarget = { 
        x: Math.random() * this.gridWidth, 
        y: Math.random() * this.gridHeight 
      };
      this.swarmVelocity = { x: 0, y: 0 };
      this.isSwarmActive = false; // Disabled during evolution
      
      // Create a circular starting cell that will evolve into a worm
      const centerX = this.center.x;
      const centerY = this.center.y;
      
      const patterns = [
        // Circle that evolves into worm
        () => {
          // Start with a simple circle (3x3)
          this.setCell(centerX, centerY, 'blue');           // Center
          this.setCell(centerX + 1, centerY, 'blue');       // Right
          this.setCell(centerX - 1, centerY, 'blue');       // Left
          this.setCell(centerX, centerY + 1, 'blue');       // Bottom
          this.setCell(centerX, centerY - 1, 'blue');       // Top
          this.setCell(centerX + 1, centerY + 1, 'white');  // Bottom-right
          this.setCell(centerX - 1, centerY + 1, 'white');  // Bottom-left
          this.setCell(centerX + 1, centerY - 1, 'white');  // Top-right
          this.setCell(centerX - 1, centerY - 1, 'white');  // Top-left
          
          // Store worm evolution data
          this.isEvolvingWorm = true;
          this.evolutionStage = 0;
          this.evolutionTimer = Date.now(); // Start timer immediately
          this.wormCenter = { x: centerX, y: centerY };
          this.wormDirection = 0; // 0=right, 1=down, 2=left, 3=up
          this.wormBody = []; // Store worm segments for twisting movement
          
          // Initialize growth and movement pattern properties
          this.wormThickness = 3;
          this.wormLength = 5;
          this.continuousGrowth = false;
          this.growthCounter = 0;
          this.movementPattern = 'straight';
          this.patternCounter = 0;
          this.circleAngle = 0;
          this.spiralRadius = 5;
          this.zigzagDirection = 1;
          this.figure8Phase = 0;
          this.curveOffset = 0;
          this.randomDirectionTimer = 0;
        }
      ];
      
      // Choose random pattern
      const randomPattern = patterns[Math.floor(Math.random() * patterns.length)];
      randomPattern();
      
      this.trackMouse();
      this.animate();
    }
    
    initializeGrid() {
      this.grid = [];
      for (let y = 0; y < this.gridHeight; y++) {
        this.grid[y] = [];
        for (let x = 0; x < this.gridWidth; x++) {
          this.grid[y][x] = null; // null = empty, string = color
        }
      }
    }
    
    setCell(x, y, color) {
      if (x < 0 || x >= this.gridWidth || y < 0 || y >= this.gridHeight) return;
      
      // Remove existing pixel if any
      const key = `${x},${y}`;
      if (this.pixels[key]) {
        this.pixels[key].remove();
        delete this.pixels[key];
      }
      
      if (color) {
        this.grid[y][x] = color;
        this.createPixelAt(x, y, color);
      } else {
        this.grid[y][x] = null;
      }
    }
    
    createPixelAt(gridX, gridY, color) {
      const pixel = document.createElement('div');
      pixel.className = `ca-pixel ${color}`;
      
      const x = gridX * this.cellSize;
      const y = gridY * this.cellSize;
      
      pixel.style.left = x + 'px';
      pixel.style.top = y + 'px';
      
      // No click handlers needed - only double-click on button destroys automatons
      
      document.body.appendChild(pixel);
      
      const key = `${gridX},${gridY}`;
      this.pixels[key] = pixel;
      
      return pixel;
    }
    
    creativeExploration(centerX, centerY) {
      // Start creative exploration: smooth disappearance without flashing
      const allPixels = Object.values(this.pixels);
      if (allPixels.length === 0) return;
      
      // Disable swarm movement during exploration
      this.isSwarmActive = false;
      
      // Direct to disappearance - NO FLASHING
      this.completeDisappearance();
    }
    
    completeDisappearance() {
      const allPixels = Object.values(this.pixels);
      
      // Remove all pixels with dramatic effect
      allPixels.forEach((pixel, index) => {
        setTimeout(() => {
          if (pixel && pixel.parentNode) {
            // Dramatic exit animation
            pixel.style.transform = 'scale(0) rotate(360deg)';
            pixel.style.opacity = '0';
            pixel.style.backgroundColor = '#ff4444';
            pixel.style.boxShadow = '0 0 20px #ff4444';
            
            setTimeout(() => {
              if (pixel.parentNode) {
                pixel.remove();
              }
            }, 300);
          }
        }, index * 30); // Stagger removal
      });
      
      // Clear all data structures
      setTimeout(() => {
        this.pixels = {};
        this.grid = [];
        this.initializeGrid();
        // Stop the automaton completely - no respawn
        this.stop();
      }, allPixels.length * 30 + 300);
    }
    
    destroyCell(gridX, gridY) {
      const key = `${gridX},${gridY}`;
      const pixel = this.pixels[key];
      
      if (pixel) {
        pixel.classList.add('destroying');
        this.grid[gridY][gridX] = null;
        
        // Create small explosion effect
        for (let i = 0; i < 3; i++) {
          setTimeout(() => {
            const dx = (Math.random() - 0.5) * 2;
            const dy = (Math.random() - 0.5) * 2;
            const newX = gridX + Math.round(dx);
            const newY = gridY + Math.round(dy);
            
            if (newX >= 0 && newX < this.gridWidth && newY >= 0 && newY < this.gridHeight) {
              if (!this.grid[newY][newX] && Math.random() < 0.3) {
                const colors = ['blue', 'white', 'grey'];
                const randomColor = colors[Math.floor(Math.random() * colors.length)];
                this.setCell(newX, newY, randomColor);
                
                // These explosion pixels are temporary
                setTimeout(() => {
                  if (this.grid[newY] && this.grid[newY][newX]) {
                    this.destroyCell(newX, newY);
                  }
                }, 800);
              }
            }
          }, i * 80);
        }
        
        setTimeout(() => {
          if (this.pixels[key]) {
            this.pixels[key].remove();
            delete this.pixels[key];
          }
        }, 600);
      }
    }
    
    trackMouse() {
      const mouseMoveHandler = (e) => {
        if (!this.isActive) return;
        
        this.mouseX = Math.floor(e.clientX / this.cellSize);
        this.mouseY = Math.floor(e.clientY / this.cellSize);
        
        // Update cursor hover effects and color changes
        this.updateCursorEffects();
      };
      
      document.addEventListener('mousemove', mouseMoveHandler);
      this.mouseMoveHandler = mouseMoveHandler;
    }
    
    updateCursorEffects() {
      // Remove all hover effects first
      Object.values(this.pixels).forEach(pixel => {
        pixel.classList.remove('cursor-hover');
      });
      
      // Apply effects to cells near cursor
      for (let dy = -this.cursorRadius; dy <= this.cursorRadius; dy++) {
        for (let dx = -this.cursorRadius; dx <= this.cursorRadius; dx++) {
          const x = this.mouseX + dx;
          const y = this.mouseY + dy;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= this.cursorRadius && x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
            const key = `${x},${y}`;
            
            if (this.pixels[key]) {
              // Existing pixel - make it glow and possibly change color
              this.pixels[key].classList.add('cursor-hover');
              
              // Color change effect (higher chance for more responsive feel)
              if (Math.random() < 0.15) {
                const currentColor = this.grid[y][x];
                const newColors = this.colors.filter(c => c !== currentColor);
                const newColor = newColors[Math.floor(Math.random() * newColors.length)];
                
                this.pixels[key].classList.remove(currentColor);
                this.pixels[key].classList.add(newColor);
                this.grid[y][x] = newColor;
              }
            }
            // Don't spawn new pixels near cursor - let the automaton evolve naturally
          }
        }
      }
    }
    
    evolveGrid() {
      const newGrid = [];
      for (let y = 0; y < this.gridHeight; y++) {
        newGrid[y] = [];
        for (let x = 0; x < this.gridWidth; x++) {
          newGrid[y][x] = this.grid[y][x];
        }
      }
      
      for (let y = 0; y < this.gridHeight; y++) {
        for (let x = 0; x < this.gridWidth; x++) {
          const neighbors = this.countNeighbors(x, y);
          const totalNeighbors = neighbors.total;
          const currentCell = this.grid[y][x];
          
          // Conway's Game of Life rules with color mixing
          if (currentCell) {
            // Cell is alive
            if (totalNeighbors < 2 || totalNeighbors > 3) {
              newGrid[y][x] = null; // Dies
            }
            // else stays alive (2 or 3 neighbors)
          } else {
            // Cell is dead
            if (totalNeighbors === 3) {
              // Comes to life - color based on neighbors
              const dominantColor = this.getDominantColor(neighbors);
              newGrid[y][x] = dominantColor;
            }
          }
        }
      }
      
      // Apply changes
      for (let y = 0; y < this.gridHeight; y++) {
        for (let x = 0; x < this.gridWidth; x++) {
          if (this.grid[y][x] !== newGrid[y][x]) {
            this.setCell(x, y, newGrid[y][x]);
          }
        }
      }
      
      this.grid = newGrid;
    }
    
    countNeighbors(x, y) {
      const neighbors = { blue: 0, white: 0, grey: 0, total: 0 };
      
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          
          const nx = x + dx;
          const ny = y + dy;
          
          if (nx >= 0 && nx < this.gridWidth && ny >= 0 && ny < this.gridHeight) {
            const neighborColor = this.grid[ny][nx];
            if (neighborColor) {
              neighbors[neighborColor]++;
              neighbors.total++;
            }
          }
        }
      }
      
      return neighbors;
    }
    
    getDominantColor(neighbors) {
      let maxCount = 0;
      let dominantColor = 'blue';
      
      this.colors.forEach(color => {
        if (neighbors[color] > maxCount) {
          maxCount = neighbors[color];
          dominantColor = color;
        }
      });
      
      return dominantColor;
    }
    
    animate() {
      if (!this.isActive) return;
      
      const now = Date.now();
      
      // Limit frame rate to 30 FPS to improve performance with multiple automata
      if (now - (this.lastFrameTime || 0) < 33) {
        this.animationId = requestAnimationFrame(() => this.animate());
        return;
      }
      this.lastFrameTime = now;
      
      let needsUpdate = false;
      
      // Handle worm evolution
      if (this.isEvolvingWorm && now - this.evolutionTimer > this.evolutionInterval) {
        this.evolveWorm();
        this.evolutionTimer = now;
        needsUpdate = true;
      }
      
      // Update worm movement (only if worm is fully evolved or not evolving)
      if (this.isSwarmActive && (!this.isEvolvingWorm || this.evolutionStage >= 5) && 
          now - this.lastSwarmUpdate > this.swarmUpdateInterval) {
        this.updateWormMovement(now);
        this.lastSwarmUpdate = now;
        needsUpdate = true;
      }
      
      // Only schedule next frame if we're still active and need updates
      if (this.isActive && (this.isEvolvingWorm || this.isSwarmActive || needsUpdate)) {
        this.animationId = requestAnimationFrame(() => this.animate());
      }
    }
    
    evolveWorm() {
      const cx = this.wormCenter.x;
      const cy = this.wormCenter.y;
      
      // Clear current form
      this.clearAllPixels();
      
      switch (this.evolutionStage) {
        case 0: // Circle (already done in spawn)
          break;
          
        case 1: // Small oval - 3 pixels thick
          this.wormThickness = 3;
          this.wormLength = 5;
          this.createWormBody(cx, cy);
          break;
          
        case 2: // Growing - 4 pixels thick
          this.wormThickness = 4;
          this.wormLength = 8;
          this.createWormBody(cx, cy);
          break;
          
        case 3: // Larger - 5 pixels thick
          this.wormThickness = 5;
          this.wormLength = 12;
          this.createWormBody(cx, cy);
          break;
          
        case 4: // Even larger - 6 pixels thick
          this.wormThickness = 6;
          this.wormLength = 16;
          this.createWormBody(cx, cy);
          break;
          
        case 5: // Start moving and continuous growth
          this.wormThickness = 7;
          this.wormLength = 20;
          this.createWormBody(cx, cy);
          this.isEvolvingWorm = false;
          this.isSwarmActive = true;
          this.continuousGrowth = true;
          this.growthCounter = 0;
          this.movementPattern = 'straight'; // Start with straight movement
          this.patternCounter = 0;
          this.circleAngle = 0;
          this.spiralRadius = 5;
          break;
      }
      
      // Only increment stage if still evolving
      if (this.evolutionStage < 5) {
        this.evolutionStage++;
      }
    }
    
    createWormBody(cx, cy) {
      this.wormBody = [];
      
      // Create a more organic, rounded worm body with wiggly edges
      for (let i = 0; i < this.wormLength; i++) {
        const segmentX = cx - Math.floor(this.wormLength / 2) + i;
        
        // Create organic thickness that varies along the body
        const centerSegment = Math.floor(this.wormLength / 2);
        const distanceFromCenter = Math.abs(i - centerSegment);
        const maxDistance = Math.floor(this.wormLength / 2);
        
        // Natural thickness variation with wiggling
        const baseThicknessRatio = 1 - (distanceFromCenter / (maxDistance + 1)) * 0.3;
        const wiggleAmplitude = Math.sin(i * 0.7) * 0.2 + Math.sin(i * 1.3) * 0.1; // Multiple frequencies for natural wiggle
        const thicknessRatio = Math.max(0.3, baseThicknessRatio + wiggleAmplitude);
        const segmentThickness = Math.max(2, Math.floor(this.wormThickness * thicknessRatio));
        
        // Add natural body curve with multiple sine waves
        const primaryCurve = Math.sin(i * 0.4) * 1.2;
        const secondaryCurve = Math.sin(i * 0.8 + Math.PI/3) * 0.6;
        const yOffset = primaryCurve + secondaryCurve;
        
        // Create rounded edges by varying the thickness at different y positions
        const halfThickness = Math.floor(segmentThickness / 2);
        
        for (let dy = -halfThickness - 1; dy <= halfThickness + 1; dy++) {
          const segmentY = cy + dy + Math.round(yOffset);
          
          // Create rounded/organic edges
          const distanceFromCenter_Y = Math.abs(dy);
          const edgeDistance = distanceFromCenter_Y / (halfThickness + 1);
          
          // Use a probability function to create rounded edges
          let includePixel = true;
          
          if (distanceFromCenter_Y > halfThickness) {
            // Edge pixels - include based on distance and some randomness for organic feel
            const edgeProbability = Math.max(0, 1 - edgeDistance * 1.5 + Math.sin(i * 1.5 + dy * 2) * 0.3);
            includePixel = Math.random() < edgeProbability;
          }
          
          if (includePixel) {
            // Create more organic color distribution with wiggles
            let color;
            
            if (i === 0 || i === this.wormLength - 1) {
              // Head and tail regions
              color = (dy === 0) ? 'blue' : (Math.random() < 0.7 ? 'blue' : 'white');
            } else {
              // Body with organic color patterns
              const colorSeed = i * 2.3 + dy * 1.7 + Math.sin(i * 0.6) * 3;
              const isMainSpine = Math.abs(dy) <= 1;
              
              if (isMainSpine) {
                // Central spine has more blue for structure
                const spinePattern = Math.sin(i * 0.8) + Math.cos(i * 1.2 + dy);
                color = spinePattern > 0 ? 'blue' : 'white';
              } else {
                // Outer areas have more varied coloring
                const outerPattern = Math.sin(colorSeed) + Math.cos(i * 0.9 + dy * 1.4);
                const randomFactor = (Math.random() - 0.5) * 0.4;
                color = (outerPattern + randomFactor) > 0 ? 'blue' : 'white';
              }
            }
            
            this.wormBody.push({
              x: segmentX, 
              y: segmentY, 
              color: color,
              segmentIndex: i,
              isEdge: distanceFromCenter_Y > halfThickness
            });
          }
        }
      }
      
      this.drawWormBody();
    }
    
    drawWormBody() {
      this.wormBody.forEach(segment => {
        this.setCell(segment.x, segment.y, segment.color);
      });
    }
    
    updateWormMovement(now) {
      // Handle continuous growth
      if (this.continuousGrowth) {
        this.growthCounter++;
        if (this.growthCounter >= 120) { // Grow every 2 seconds (slow pace)
          this.growthCounter = 0;
          this.wormLength += 2; // Grow length
          if (this.wormLength % 8 === 0) { // Increase thickness occasionally
            this.wormThickness++;
          }
        }
      }
      
      // Handle resting behavior (worms sometimes pause)
      if (this.isResting) {
        this.restDuration--;
        if (this.restDuration <= 0) {
          this.isResting = false;
        } else {
          return; // Skip movement while resting
        }
      }
      
      // Change movement patterns based on worm size
      this.patternCounter++;
      if (this.patternCounter >= 100) { // Change pattern every ~1.5 seconds
        this.patternCounter = 0;
        this.chooseMovementPattern();
      }
      
      // Execute current movement pattern
      this.executeMovementPattern();
    }
    
    chooseMovementPattern() {
      const patterns = ['straight', 'circle', 'spiral', 'figure8', 'zigzag', 'random', 'curve'];
      
      // Larger worms can do more complex patterns
      let availablePatterns = ['straight', 'random'];
      
      if (this.wormLength > 15) {
        availablePatterns.push('circle', 'curve');
      }
      
      if (this.wormLength > 25) {
        availablePatterns.push('spiral', 'zigzag');
      }
      
      if (this.wormLength > 40) {
        availablePatterns.push('figure8');
      }
      
      // Add randomness - sometimes stick with current pattern, sometimes change
      if (Math.random() < 0.3 && this.movementPattern !== 'straight') {
        // 30% chance to keep current pattern for continuity
        return;
      }
      
      this.movementPattern = availablePatterns[Math.floor(Math.random() * availablePatterns.length)];
      
      // Reset pattern-specific counters with random starting values
      this.circleAngle = Math.random() * Math.PI * 2; // Start at random angle
      this.spiralRadius = Math.min(this.wormLength / 4, 15) + Math.random() * 5;
      this.zigzagDirection = Math.random() < 0.5 ? 1 : -1; // Random initial direction
      this.figure8Phase = Math.random() * Math.PI * 2;
      this.curveOffset = Math.random() * Math.PI;
      this.randomDirectionTimer = 0;
    }
    
    executeMovementPattern() {
      let newDirection = this.wormDirection;
      
      switch (this.movementPattern) {
        case 'straight':
          // Occasionally change direction for straight movement
          if (Math.random() < 0.08) {
            newDirection = Math.floor(Math.random() * 4);
          }
          break;
          
        case 'circle':
          // Move in a circular pattern with random variations
          this.circleAngle += 0.15 + (Math.random() - 0.5) * 0.1; // Add randomness to speed
          const circleDirections = [0, 1, 2, 3]; // Right, Down, Left, Up
          newDirection = circleDirections[Math.floor(this.circleAngle / (Math.PI / 2)) % 4];
          
          // Randomly reverse circle direction sometimes
          if (Math.random() < 0.02) {
            this.circleAngle += Math.PI; // Reverse direction
          }
          break;
          
        case 'spiral':
          // Move in a spiral with natural variations
          this.circleAngle += 0.12 + (Math.random() - 0.5) * 0.08;
          this.spiralRadius += 0.1 + (Math.random() - 0.5) * 0.05;
          if (this.spiralRadius > 20) this.spiralRadius = 5 + Math.random() * 3;
          
          const spiralX = Math.cos(this.circleAngle) * this.spiralRadius;
          const spiralY = Math.sin(this.circleAngle) * this.spiralRadius;
          
          if (Math.abs(spiralX) > Math.abs(spiralY)) {
            newDirection = spiralX > 0 ? 0 : 2;
          } else {
            newDirection = spiralY > 0 ? 1 : 3;
          }
          break;
          
        case 'figure8':
          // More natural figure-8 with variations
          this.figure8Phase += 0.08 + (Math.random() - 0.5) * 0.04;
          const figure8X = Math.sin(this.figure8Phase);
          const figure8Y = Math.sin(this.figure8Phase * 2) * (0.8 + Math.random() * 0.4);
          
          if (Math.abs(figure8X) > Math.abs(figure8Y)) {
            newDirection = figure8X > 0 ? 0 : 2;
          } else {
            newDirection = figure8Y > 0 ? 1 : 3;
          }
          break;
          
        case 'zigzag':
          // More organic zigzag movement
          if (this.patternCounter % (8 + Math.floor(Math.random() * 6)) === 0) {
            this.zigzagDirection *= -1;
          }
          newDirection = this.zigzagDirection > 0 ? 0 : 2;
          if (this.patternCounter % (15 + Math.floor(Math.random() * 10)) === 0) {
            newDirection = Math.random() < 0.5 ? 1 : 3;
          }
          break;
          
        case 'curve':
          // Gentle curving movement
          this.curveOffset += 0.1;
          const curveInfluence = Math.sin(this.curveOffset) * 0.5;
          
          if (Math.random() < 0.1) {
            if (curveInfluence > 0.2) {
              newDirection = (this.wormDirection + 1) % 4; // Turn right
            } else if (curveInfluence < -0.2) {
              newDirection = (this.wormDirection + 3) % 4; // Turn left
            }
          }
          break;
          
        case 'random':
          // Completely random movement with some momentum
          this.randomDirectionTimer++;
          if (this.randomDirectionTimer > (5 + Math.floor(Math.random() * 10))) {
            newDirection = Math.floor(Math.random() * 4);
            this.randomDirectionTimer = 0;
          }
          break;
      }
      
      this.wormDirection = newDirection;
      
      // Add general randomness - make direction changes more gradual and curved
      if (Math.random() < 0.08) { // Increased frequency for more organic movement
        // Prefer turning rather than random direction for more natural curves
        const possibleTurns = [
          (this.wormDirection + 1) % 4, // Turn right
          (this.wormDirection + 3) % 4  // Turn left
        ];
        
        // 70% chance to turn, 30% chance for any direction
        if (Math.random() < 0.7) {
          this.wormDirection = possibleTurns[Math.floor(Math.random() * 2)];
        } else {
          this.wormDirection = Math.floor(Math.random() * 4);
        }
      }
      
      // Add subtle continuous curving
      if (Math.random() < 0.15) { // 15% chance each frame for subtle turns
        // Slight bias towards curving
        const turnBias = Math.sin(this.generation * 0.1) > 0 ? 1 : 3; // Slight left or right bias
        this.wormDirection = (this.wormDirection + turnBias) % 4;
      }
      
      // Sometimes rest (like real worms do) - but less frequently
      if (Math.random() < 0.008) { // Reduced rest frequency
        this.isResting = true;
        this.restDuration = Math.floor(Math.random() * 8) + 3; // Shorter rests
        return;
      }
      
      // Move worm head
      this.moveWormHead();
    }
    
    moveWormHead() {
      if (this.wormBody.length === 0) return;
      
      // Find the current head position (highest segmentIndex)
      const maxSegmentIndex = Math.max(...this.wormBody.map(p => p.segmentIndex || 0));
      const headPixels = this.wormBody.filter(p => (p.segmentIndex || 0) === maxSegmentIndex);
      
      if (headPixels.length === 0) return;
      
      // Calculate head center
      const headCenterX = Math.round(headPixels.reduce((sum, p) => sum + p.x, 0) / headPixels.length);
      const headCenterY = Math.round(headPixels.reduce((sum, p) => sum + p.y, 0) / headPixels.length);
      
      let newHeadX = headCenterX;
      let newHeadY = headCenterY;
      
      // Calculate new head position based on direction
      switch (this.wormDirection) {
        case 0: newHeadX++; break; // Right
        case 1: newHeadY++; break; // Down
        case 2: newHeadX--; break; // Left
        case 3: newHeadY--; break; // Up
      }
      
      // Check bounds
      const halfThickness = Math.floor(this.wormThickness / 2);
      if (newHeadX < halfThickness + 2 || newHeadX >= this.gridWidth - halfThickness - 2 || 
          newHeadY < halfThickness + 2 || newHeadY >= this.gridHeight - halfThickness - 2) {
        // Change direction if hitting bounds
        this.wormDirection = (this.wormDirection + 2) % 4; // Reverse direction
        return;
      }
      
      // Create new head segment with organic, rounded shape
      const newSegmentIndex = maxSegmentIndex + 1;
      const newHeadSegments = [];
      
      // Calculate natural thickness for this segment with wiggle
      const wiggleAmplitude = Math.sin(newSegmentIndex * 0.7) * 0.2;
      const segmentThickness = Math.max(2, Math.floor((this.wormThickness - 1) * (0.8 + wiggleAmplitude)));
      const segmentHalfThickness = Math.floor(segmentThickness / 2);
      
      // Add body curve at this position
      const primaryCurve = Math.sin(newSegmentIndex * 0.4) * 1.2;
      const secondaryCurve = Math.sin(newSegmentIndex * 0.8 + Math.PI/3) * 0.6;
      const baseCurveOffset = primaryCurve + secondaryCurve;
      
      for (let dy = -segmentHalfThickness - 1; dy <= segmentHalfThickness + 1; dy++) {
        const segmentY = newHeadY + dy + Math.round(baseCurveOffset);
        
        // Create rounded head shape
        const distanceFromCenter_Y = Math.abs(dy);
        const edgeDistance = distanceFromCenter_Y / (segmentHalfThickness + 1);
        
        let includePixel = true;
        
        if (distanceFromCenter_Y > segmentHalfThickness) {
          // Edge pixels for rounded head
          const edgeProbability = Math.max(0, 1 - edgeDistance * 1.2 + Math.sin(newSegmentIndex * 1.8 + dy * 2.5) * 0.25);
          includePixel = Math.random() < edgeProbability;
        }
        
        if (includePixel) {
          // Natural head coloring with organic patterns
          let color;
          
          if (dy === 0) {
            // Center of head - always blue for structure
            color = 'blue';
          } else {
            // Head edges with organic color mixing
            const headColorPattern = Math.sin(newSegmentIndex * 1.1 + dy * 1.8) + Math.cos(dy * 2.3);
            const randomFactor = (Math.random() - 0.5) * 0.3;
            color = (headColorPattern + randomFactor) > 0 ? 'blue' : 'white';
          }
          
          newHeadSegments.push({
            x: newHeadX, 
            y: segmentY, 
            color: color,
            segmentIndex: newSegmentIndex,
            isEdge: distanceFromCenter_Y > segmentHalfThickness
          });
        }
      }
      
      // Add new head segments
      this.wormBody.push(...newHeadSegments);
      
      // Remove tail segments to maintain length (but allow growth)
      const maxSegments = this.wormLength * this.wormThickness * 1.2; // Allow for organic variations
      while (this.wormBody.length > maxSegments) {
        // Remove the oldest segments (lowest segmentIndex)
        const minSegmentIndex = Math.min(...this.wormBody.map(p => p.segmentIndex || 0));
        this.wormBody = this.wormBody.filter(p => (p.segmentIndex || 0) !== minSegmentIndex);
      }
      
      // Redraw worm
      this.clearAllPixels();
      this.drawWormBody();
      
      // Update center for other calculations
      this.wormCenter = {x: newHeadX, y: newHeadY};
    }
    
    clearAllPixels() {
      Object.values(this.pixels).forEach(pixel => pixel.remove());
      this.pixels = {};
      this.initializeGrid();
    }
    
    highlightEntireAutomaton(highlight) {
      // Highlight or unhighlight all pixels in the automaton
      Object.values(this.pixels).forEach(pixel => {
        if (pixel && pixel.parentNode) {
          if (highlight) {
            pixel.style.boxShadow = '0 0 8px #00ffff, 0 0 16px #00ffff';
            pixel.style.filter = 'brightness(1.3)';
          } else {
            // Reset to original colors
            const isBlue = pixel.className.includes('blue');
            pixel.style.boxShadow = `0 0 2px ${isBlue ? '#005fef' : '#ffffff'}`;
            pixel.style.filter = 'brightness(1)';
          }
        }
      });
    }
    
    destroyAll() {
      // Instantly destroy all pixels without animation
      Object.values(this.pixels).forEach(pixel => {
        if (pixel && pixel.parentNode) {
          pixel.remove();
        }
      });
      this.pixels = {};
      this.isActive = false;
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
        this.animationId = null;
      }
    }
    
    updateSwarmMovement(now) {
      // Handle resting behavior (insects sometimes pause)
      if (this.isResting) {
        this.restDuration--;
        if (this.restDuration <= 0) {
          this.isResting = false;
        } else {
          return; // Skip movement while resting
        }
      }
      
      // Calculate current swarm center
      const pixelPositions = Object.keys(this.pixels).map(key => {
        const [x, y] = key.split(',').map(Number);
        return { x, y };
      });
      
      if (pixelPositions.length === 0) return;
      
      // Find center of mass
      const centerX = pixelPositions.reduce((sum, pos) => sum + pos.x, 0) / pixelPositions.length;
      const centerY = pixelPositions.reduce((sum, pos) => sum + pos.y, 0) / pixelPositions.length;
      
      this.swarmCenter = { x: centerX, y: centerY };
      
      // Insect-like behavior: curious movement with occasional resting
      if (Math.random() < this.swarmCuriosity) {
        // Sometimes rest (like insects do) - but much shorter
        if (Math.random() < 0.08) {
          this.isResting = true;
          this.restDuration = Math.floor(Math.random() * 8) + 3; // Rest 3-10 frames (very short)
          return;
        }
        
        // Sometimes move toward mouse (attracted to movement)
        if (Math.random() < 0.4) {
          this.swarmTarget = { x: this.mouseX, y: this.mouseY };
        } 
        // Sometimes move toward corners (insects like edges/corners)
        else if (Math.random() < 0.3) {
          const corners = [
            { x: 10, y: 10 },
            { x: this.gridWidth - 10, y: 10 },
            { x: 10, y: this.gridHeight - 10 },
            { x: this.gridWidth - 10, y: this.gridHeight - 10 }
          ];
          this.swarmTarget = corners[Math.floor(Math.random() * corners.length)];
        }
        // Sometimes move in wavy patterns (like butterflies)
        else if (Math.random() < 0.3) {
          const angle = Math.random() * Math.PI * 2;
          const distance = 20 + Math.random() * 30;
          this.swarmTarget = {
            x: this.swarmCenter.x + Math.cos(angle) * distance,
            y: this.swarmCenter.y + Math.sin(angle) * distance
          };
        }
        // Sometimes explore randomly
        else {
          this.swarmTarget = {
            x: Math.random() * this.gridWidth,
            y: Math.random() * this.gridHeight
          };
        }
      }
      
      // Calculate movement direction toward target
      const dx = this.swarmTarget.x - this.swarmCenter.x;
      const dy = this.swarmTarget.y - this.swarmCenter.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance > 2) {
        // Normalize and apply speed with some waviness for natural movement
        const waveOffset = Math.sin(now * 0.005) * 0.1; // Gentle wave motion
        this.swarmVelocity.x = (dx / distance) * this.swarmSpeed + waveOffset;
        this.swarmVelocity.y = (dy / distance) * this.swarmSpeed + Math.cos(now * 0.007) * 0.1;
        
        // Apply movement to all pixels
        this.moveSwarm();
      }
    }
    
    moveSwarm() {
      // Special handling for evolved worm - use worm-specific movement
      if (!this.isEvolvingWorm && this.evolutionStage >= 5) {
        // Worm movement is handled in updateWormMovement
        return;
      }
      
      // Fallback for any other movement needs
      return;
    }
    
    moveLizardAsUnit() {
      // Calculate movement offset
      const moveX = Math.round(this.swarmVelocity.x);
      const moveY = Math.round(this.swarmVelocity.y);
      
      if (moveX === 0 && moveY === 0) return; // No movement
      
      // Get current lizard center
      const currentCenter = this.getLizardCenter();
      const newCenterX = currentCenter.x + moveX;
      const newCenterY = currentCenter.y + moveY;
      
      // Check if new position is within bounds
      if (newCenterX < 6 || newCenterX > this.gridWidth - 6 || 
          newCenterY < 3 || newCenterY > this.gridHeight - 3) {
        return; // Don't move if it would go out of bounds
      }
      
      // Clear current lizard
      this.clearAllPixels();
      
      // Redraw lizard at new position
      this.lizardCenter = { x: newCenterX, y: newCenterY };
      this.drawCompleteLizard(newCenterX, newCenterY);
    }
    
    getLizardCenter() {
      const pixelPositions = Object.keys(this.pixels).map(key => {
        const [x, y] = key.split(',').map(Number);
        return { x, y };
      });
      
      if (pixelPositions.length === 0) return this.lizardCenter;
      
      const centerX = pixelPositions.reduce((sum, pos) => sum + pos.x, 0) / pixelPositions.length;
      const centerY = pixelPositions.reduce((sum, pos) => sum + pos.y, 0) / pixelPositions.length;
      
      return { x: Math.round(centerX), y: Math.round(centerY) };
    }
    
    drawCompleteLizard(cx, cy) {
      // Draw the complete lizard with stripes at the given center position
      for (let x = cx - 6; x <= cx + 5; x++) {
        if (x >= cx - 3 && x <= cx + 3) {
          // Body with stripes
          const color = (x + cy) % 3 === 0 ? 'white' : (x + cy) % 3 === 1 ? 'grey' : 'blue';
          this.setCell(x, cy, color);
          this.setCell(x, cy + 1, color);
          this.setCell(x, cy - 1, color);
        } else if (x < cx - 3) {
          this.setCell(x, cy, 'blue'); // Tail
        } else {
          this.setCell(x, cy, 'blue'); // Head
        }
      }
      // Legs
      this.setCell(cx - 2, cy + 2, 'grey');
      this.setCell(cx - 1, cy + 2, 'grey');
      this.setCell(cx + 1, cy + 2, 'grey');
      this.setCell(cx + 2, cy + 2, 'grey');
      this.setCell(cx - 2, cy - 2, 'grey');
      this.setCell(cx - 1, cy - 2, 'grey');
      this.setCell(cx + 1, cy - 2, 'grey');
      this.setCell(cx + 2, cy - 2, 'grey');
      // Head
      this.setCell(cx + 4, cy, 'blue');
      this.setCell(cx + 5, cy, 'blue');
      this.setCell(cx + 4, cy + 1, 'blue');
      this.setCell(cx + 4, cy - 1, 'blue');
    }
    
    stop() {
      this.isActive = false;
      
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
      
      if (this.mouseMoveHandler) {
        document.removeEventListener('mousemove', this.mouseMoveHandler);
      }
      
      // Remove all pixels
      Object.values(this.pixels).forEach(pixel => pixel.remove());
      this.pixels = {};
    }
  }

  // Flower Cellular Automaton - blooms in rings with color waves
  class FlowerAutomaton {
    constructor() {
      this.cellSize = 6;
      this.gridWidth = Math.floor(window.innerWidth / this.cellSize);
      this.gridHeight = Math.floor(window.innerHeight / this.cellSize);
      this.pixels = {};
      this.center = { x: 0, y: 0 };
      this.isActive = false;
      this.isDestroying = false; // Prevent multiple destruction calls
      this.animationId = null;
      this.bloomRadius = 0;
      this.maxRadius = 15;
      this.colorPhase = 0;
      this.bloomSpeed = 0.2;
      this.colorSpeed = 0.1;
      this.patternType = 0; // Pattern variation: 0=circular, 1=petal, 2=spiral
      this.colors = ['blue', 'white']; // Blue and white only
      this.colorValues = {
        'blue': '#005fef',
        'white': '#ffffff'
      };
    }
    
    spawn(spawnX = null, spawnY = null) {
      if (this.isActive) return;
      
      this.isActive = true;
      const centerX = spawnX || Math.floor(Math.random() * (this.gridWidth - 30)) + 15;
      const centerY = spawnY || Math.floor(Math.random() * (this.gridHeight - 30)) + 15;
      
      this.center = { x: centerX, y: centerY };
      this.bloomRadius = 0;
      this.colorPhase = 0;
      
      this.animate();
    }
    
    animate() {
      if (!this.isActive) return;
      
      const now = Date.now();
      
      // Limit frame rate to 30 FPS to improve performance with multiple automata
      if (now - (this.lastFrameTime || 0) < 33) {
        this.animationId = requestAnimationFrame(() => this.animate());
        return;
      }
      this.lastFrameTime = now;
      
      // Clear previous frame
      Object.values(this.pixels).forEach(pixel => pixel.remove());
      this.pixels = {};
      
      // Expand bloom radius
      this.bloomRadius += this.bloomSpeed;
      this.colorPhase += this.colorSpeed;
      
      // Create varied flower patterns
      for (let ring = 0; ring <= Math.floor(this.bloomRadius); ring++) {
        this.drawFlowerRing(ring);
      }
      
      // Continue blooming or start new cycle with pattern variation
      if (this.bloomRadius > this.maxRadius) {
        this.bloomRadius = 0;
        this.maxRadius = 8 + Math.random() * 12; // Vary flower size
        this.bloomSpeed = 0.15 + Math.random() * 0.3; // Vary bloom speed
        this.colorSpeed = 0.05 + Math.random() * 0.15; // Vary color wave speed
        // Change pattern type
        this.patternType = Math.floor(Math.random() * 3); // 3 different patterns
      }
      
      // Only schedule next frame if we're still active
      if (this.isActive) {
        this.animationId = requestAnimationFrame(() => this.animate());
      }
    }
    
    drawFlowerRing(radius) {
      const patternType = this.patternType || 0;
      
      if (patternType === 0) {
        // Circular pattern
        const angleStep = radius === 0 ? 1 : Math.PI * 2 / (radius * 8);
        
        for (let angle = 0; angle < Math.PI * 2; angle += angleStep) {
          const x = Math.round(this.center.x + Math.cos(angle) * radius);
          const y = Math.round(this.center.y + Math.sin(angle) * radius);
          this.drawFlowerPixel(x, y, radius);
        }
      } else if (patternType === 1) {
        // Petal pattern (flower-like)
        const petalCount = 6;
        const angleStep = Math.PI * 2 / (radius * 12);
        
        for (let angle = 0; angle < Math.PI * 2; angle += angleStep) {
          const petalIntensity = Math.sin(angle * petalCount) * 0.5 + 0.5;
          const adjustedRadius = radius * (0.5 + petalIntensity * 0.5);
          const x = Math.round(this.center.x + Math.cos(angle) * adjustedRadius);
          const y = Math.round(this.center.y + Math.sin(angle) * adjustedRadius);
          this.drawFlowerPixel(x, y, radius);
        }
      } else {
        // Spiral pattern
        const spiralTightness = 0.3;
        const points = radius * 6;
        
        for (let i = 0; i < points; i++) {
          const angle = (i / points) * Math.PI * 4; // 2 full rotations
          const spiralRadius = (i / points) * radius;
          const x = Math.round(this.center.x + Math.cos(angle) * spiralRadius);
          const y = Math.round(this.center.y + Math.sin(angle) * spiralRadius);
          this.drawFlowerPixel(x, y, radius);
        }
      }
    }
    
    drawFlowerPixel(x, y, radius) {
      if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
        // Color wave effect based on distance and phase
        const waveValue = Math.sin(this.colorPhase + radius * 0.5) * 0.5 + 0.5;
        const colorChoice = (Math.floor(radius + waveValue * 2) % 2 === 0) ? 'blue' : 'white';
        this.setCell(x, y, colorChoice);
      }
    }
    
    setCell(x, y, color) {
      const key = `${x},${y}`;
      if (this.pixels[key]) return;
      
      const pixel = document.createElement('div');
      pixel.className = `ca-pixel ${color}`;
      // Don't set inline styles - let CSS handle colors including light mode
      
      const pixelX = x * this.cellSize;
      const pixelY = y * this.cellSize;
      
      pixel.style.left = pixelX + 'px';
      pixel.style.top = pixelY + 'px';
      
      // Add click handler for destruction with animation
      pixel.addEventListener('click', (e) => {
        e.stopPropagation();
        this.creativeExploration();
      });
      
      // Add hover effects like worm
      pixel.addEventListener('mouseenter', () => {
        pixel.style.transform = 'scale(1.1)';
        pixel.style.cursor = 'pointer';
      });
      
      pixel.addEventListener('mouseleave', () => {
        pixel.style.transform = 'scale(1)';
      });
      
      document.body.appendChild(pixel);
      this.pixels[key] = pixel;
    }
    
    destroyAll() {
      Object.values(this.pixels).forEach(pixel => {
        if (pixel && pixel.parentNode) {
          pixel.remove();
        }
      });
      this.pixels = {};
      this.isActive = false;
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
        this.animationId = null;
      }
    }
    
    creativeExploration() {
      // Start creative exploration: smooth disappearance without flashing
      const allPixels = Object.values(this.pixels);
      if (allPixels.length === 0) return;
      
      // Disable animation during exploration
      this.isActive = false;
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
      
      // Direct to disappearance - NO FLASHING
      this.completeDisappearance();
    }
    
    completeDisappearance() {
      const allPixels = Object.values(this.pixels);
      const totalPixels = allPixels.length;
      const maxDisappearTime = 2500; // 2.5 seconds max for disappearance
      const staggerDelay = Math.min(15, maxDisappearTime / totalPixels); // Faster stagger
      
      allPixels.forEach((pixel, index) => {
        setTimeout(() => {
          if (pixel && pixel.parentNode) {
            pixel.style.transform = 'scale(0) rotate(360deg)';
            pixel.style.opacity = '0';
            
            setTimeout(() => {
              if (pixel && pixel.parentNode) {
                pixel.remove();
              }
            }, 200); // Faster removal
          }
        }, index * staggerDelay);
      });
      
      setTimeout(() => {
        this.pixels = {};
        this.isActive = false;
      }, maxDisappearTime + 200);
    }
  }

  // Moss Cellular Automaton - spreads like a virus with waves
  class MossAutomaton {
    constructor() {
      this.cellSize = 6;
      this.gridWidth = Math.floor(window.innerWidth / this.cellSize);
      this.gridHeight = Math.floor(window.innerHeight / this.cellSize);
      this.pixels = {};
      this.center = { x: 0, y: 0 };
      this.isActive = false;
      this.isDestroying = false; // Prevent multiple destruction calls
      this.animationId = null;
      this.colonies = [];
      this.generation = 0;
      this.spreadRate = 0.15;
      this.wavePhase = 0;
      this.colors = ['blue', 'white']; // Blue and white only
      this.colorValues = {
        'blue': '#005fef',
        'white': '#ffffff'
      };
    }
    
    spawn(spawnX = null, spawnY = null) {
      if (this.isActive) return;
      
      this.isActive = true;
      const centerX = spawnX || Math.floor(Math.random() * (this.gridWidth - 20)) + 10;
      const centerY = spawnY || Math.floor(Math.random() * (this.gridHeight - 20)) + 10;
      
      this.center = { x: centerX, y: centerY };
      this.colonies = [{ x: centerX, y: centerY, age: 0 }];
      this.generation = 0;
      this.wavePhase = 0;
      
      this.animate();
    }
    
    animate() {
      if (!this.isActive) return;
      
      const now = Date.now();
      
      // Limit frame rate to 30 FPS to improve performance with multiple automata
      if (now - (this.lastFrameTime || 0) < 33) {
        this.animationId = requestAnimationFrame(() => this.animate());
        return;
      }
      this.lastFrameTime = now;
      
      this.generation++;
      this.wavePhase += 0.1;
      
      // Spread moss
      this.spreadMoss();
      
      // Redraw all colonies with wave effects
      this.redrawMoss();
      
      // Only schedule next frame if we're still active
      if (this.isActive) {
        this.animationId = requestAnimationFrame(() => this.animate());
      }
    }
    
    spreadMoss() {
      const newColonies = [];
      
      for (let colony of this.colonies) {
        colony.age++;
        
        // Each colony tries to spread - increased connection rate
        if (Math.random() < this.spreadRate * 1.5) { // Higher spread rate for connectivity
          // Prioritize adjacent cells for better connectivity
          const directions = [
            { x: 0, y: 1 }, { x: 1, y: 0 }, { x: 0, y: -1 }, { x: -1, y: 0 }, // Adjacent first
            { x: 1, y: 1 }, { x: -1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 } // Diagonal second
          ];
          
          // Try multiple directions to ensure connectivity
          for (let direction of directions) {
            if (Math.random() < 0.6) { // 60% chance per direction for denser growth
              const newX = colony.x + direction.x;
              const newY = colony.y + direction.y;
              
              // Check bounds and if position is free
              if (newX >= 0 && newX < this.gridWidth && 
                  newY >= 0 && newY < this.gridHeight &&
                  !this.colonies.find(c => c.x === newX && c.y === newY) &&
                  !newColonies.find(c => c.x === newX && c.y === newY)) {
                
                newColonies.push({ x: newX, y: newY, age: 0 });
                break; // Only one new colony per existing colony per frame
              }
            }
          }
        }
      }
      
      this.colonies.push(...newColonies);
      
      // Limit colony count for performance
      if (this.colonies.length > 500) {
        this.colonies = this.colonies.slice(-500);
      }
    }
    
    redrawMoss() {
      // Clear existing pixels
      Object.values(this.pixels).forEach(pixel => pixel.remove());
      this.pixels = {};
      
      // Draw all colonies with wave color effects
      for (let colony of this.colonies) {
        const waveValue = Math.sin(this.wavePhase + colony.x * 0.1 + colony.y * 0.1) * 0.5 + 0.5;
        const colorChoice = (Math.floor(colony.age * 0.1 + waveValue * 2) % 2 === 0) ? 'blue' : 'white';
        
        this.setCell(colony.x, colony.y, colorChoice);
      }
    }
    
    setCell(x, y, color) {
      const key = `${x},${y}`;
      if (this.pixels[key]) return;
      
      const pixel = document.createElement('div');
      pixel.className = `ca-pixel ${color}`;
      // Don't set inline styles - let CSS handle colors including light mode
      
      const pixelX = x * this.cellSize;
      const pixelY = y * this.cellSize;
      
      pixel.style.left = pixelX + 'px';
      pixel.style.top = pixelY + 'px';
      
      // Add click handler for destruction with animation
      pixel.addEventListener('click', (e) => {
        e.stopPropagation();
        this.creativeExploration();
      });
      
      // Add hover effects like worm
      pixel.addEventListener('mouseenter', () => {
        pixel.style.transform = 'scale(1.1)';
        pixel.style.cursor = 'pointer';
      });
      
      pixel.addEventListener('mouseleave', () => {
        pixel.style.transform = 'scale(1)';
      });
      
      document.body.appendChild(pixel);
      this.pixels[key] = pixel;
    }
    
    destroyAll() {
      Object.values(this.pixels).forEach(pixel => {
        if (pixel && pixel.parentNode) {
          pixel.remove();
        }
      });
      this.pixels = {};
      this.isActive = false;
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
        this.animationId = null;
      }
    }
    
    creativeExploration() {
      // Start creative exploration: smooth disappearance without flashing
      const allPixels = Object.values(this.pixels);
      if (allPixels.length === 0) return;
      
      // Disable animation during exploration
      this.isActive = false;
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
      
      // Direct to disappearance - NO FLASHING
      this.completeDisappearance();
    }
    
    completeDisappearance() {
      const allPixels = Object.values(this.pixels);
      const totalPixels = allPixels.length;
      const maxDisappearTime = 2500; // 2.5 seconds max for disappearance
      const staggerDelay = Math.min(15, maxDisappearTime / totalPixels); // Faster stagger
      
      allPixels.forEach((pixel, index) => {
        setTimeout(() => {
          if (pixel && pixel.parentNode) {
            pixel.style.transform = 'scale(0) rotate(360deg)';
            pixel.style.opacity = '0';
            
            setTimeout(() => {
              if (pixel && pixel.parentNode) {
                pixel.remove();
              }
            }, 200); // Faster removal
          }
        }, index * staggerDelay);
      });
      
      setTimeout(() => {
        this.pixels = {};
        this.isActive = false;
      }, maxDisappearTime + 200);
    }
  }



  // Global automaton instances management
  // Cellular Automaton Management System
  let draggedType = null;
  let dragSeed = null;
  let hoverTooltip = null;
  let currentRenameId = null;

  const cellularAutomatonBtn = document.querySelector('.cellular-automaton-btn');
  const caMenu = document.getElementById('ca-menu');
  
  // Toggle menu visibility
  cellularAutomatonBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    
    // Normal menu toggle behavior
    if (caMenu.style.display === 'flex') {
      caMenu.style.display = 'none';
    } else {
      caMenu.style.display = 'flex';
    }
  });

  // Add event listener for CA info icon
  const caInfoIcon = document.querySelector('.ca-info-icon');
  if (caInfoIcon) {
    caInfoIcon.addEventListener('click', (e) => {
      console.log('Info icon clicked!'); // Debug log
      e.preventDefault();
      e.stopPropagation();
      
      // Normal info modal behavior
      showCAInfo();
    });
  }

  // Close menu when clicking outside
  document.addEventListener('click', (e) => {
    const infoModal = document.getElementById('ca-info-modal');
    
    // Don't close if clicking on the info icon specifically
    if (e.target.closest('.ca-info-icon')) {
      return;
    }
    
    // Don't close if clicking inside the info modal
    if (infoModal && infoModal.contains(e.target)) {
      return;
    }
    
    // Close automata menu if clicking outside of it and not on the button
    if (!caMenu.contains(e.target) && 
        !cellularAutomatonBtn.contains(e.target) &&
        !e.target.closest('.theme-toggle-btn')) {
      caMenu.style.display = 'none';
    }
  });

  // Initialize the active list on page load
  updateActiveList();

  // Drag and Drop functionality
  function setupDragAndDrop() {
    let isDragging = false;
    
    // Use event delegation for drag start
    document.addEventListener('dragstart', (e) => {
      if (e.target.classList.contains('launch-item')) {
        isDragging = true;
        draggedType = e.target.getAttribute('data-automaton-type');
        e.dataTransfer.effectAllowed = 'copy';
        e.dataTransfer.setData('text/plain', draggedType);
        
        console.log('Drag started with type:', draggedType);
        
        // Create visual seed
        createDragSeed();
        
        // Don't hide menu during drag - keep it open
      }
    });

    // Handle clicks on launch items
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('launch-item') && !isDragging) {
        const type = e.target.getAttribute('data-automaton-type');
        console.log('Click launch:', type, 'Current automata count:', automatonInstances.length);
        
        // Check if we've reached the maximum limit
        if (automatonInstances.length >= 3) {
          console.log('Reached maximum limit, showing message...');
          
          // Always show a visual notification
          const notification = document.createElement('div');
          notification.textContent = 'Maximum of 3 automata allowed for optimal performance';
          notification.style.cssText = `
            position: fixed;
            top: 50px;
            right: 20px;
            background: #ff4444;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 10000;
            font-family: monospace;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
          `;
          document.body.appendChild(notification);
          setTimeout(() => notification.remove(), 3000);
          
          // Flash the item to indicate the action was attempted
          e.target.classList.add('gentle-flash');
          setTimeout(() => e.target.classList.remove('gentle-flash'), 300);
          
          // Show message in terminal if it's open
          const terminalWindow = document.getElementById('terminal-window');
          const computedDisplay = window.getComputedStyle(terminalWindow).display;
          const isTerminalOpen = (terminalWindow.style.display === 'flex' || 
                                 (terminalWindow.style.display === '' && computedDisplay === 'flex')) && 
                                !terminalWindow.classList.contains('hide');
          console.log('Terminal open?', isTerminalOpen);
          if (isTerminalOpen) {
            print('automata: maximum of 3 automata allowed for optimal performance');
          }
          return;
        }
        
        // Normal launch behavior
        console.log('Launching automaton...');
        const newInstance = launchAutomaton(type);
        console.log('Launch result:', newInstance);
      }
    });

    // Reset drag state
    document.addEventListener('dragend', (e) => {
      if (e.target.classList.contains('launch-item')) {
        console.log('Drag ended');
        isDragging = false;
        removeDragSeed();
        draggedType = null;
        
        // Small delay to prevent click after drag
        setTimeout(() => {
          isDragging = false;
        }, 100);
      }
    });

    // Global drag events for the whole document
    document.addEventListener('dragover', (e) => {
      if (draggedType) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
        if (dragSeed) {
          dragSeed.style.left = e.clientX + 'px';
          dragSeed.style.top = e.clientY + 'px';
        }
      }
    });

    document.addEventListener('drop', (e) => {
      if (draggedType) {
        e.preventDefault();
        console.log('Drop detected with type:', draggedType);
        
        // Check if we've reached the maximum limit
        if (automatonInstances.length >= 3) {
          // Always show a visual notification
          const notification = document.createElement('div');
          notification.textContent = 'Maximum of 3 automata allowed for optimal performance';
          notification.style.cssText = `
            position: fixed;
            top: 50px;
            right: 20px;
            background: #ff4444;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 10000;
            font-family: monospace;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
          `;
          document.body.appendChild(notification);
          setTimeout(() => notification.remove(), 3000);
          
          // Show message in terminal if it's open
          const terminalWindow = document.getElementById('terminal-window');
          const computedDisplay = window.getComputedStyle(terminalWindow).display;
          const isTerminalOpen = (terminalWindow.style.display === 'flex' || 
                                 (terminalWindow.style.display === '' && computedDisplay === 'flex')) && 
                                !terminalWindow.classList.contains('hide');
          if (isTerminalOpen) {
            print('automata: maximum of 3 automata allowed for optimal performance');
          }
          
          removeDragSeed();
          draggedType = null;
          isDragging = false;
          return;
        }
        
        const x = Math.floor(e.clientX / 6);
        const y = Math.floor(e.clientY / 6);
        console.log('Drop coordinates:', x, y);
        
        // Launch directly
        const newInstance = launchAutomaton(draggedType, x, y);
        
        removeDragSeed();
        draggedType = null;
        isDragging = false;
      }
    });
  }

  function createDragSeed() {
    dragSeed = document.createElement('div');
    dragSeed.className = 'ca-drag-seed';
    document.body.appendChild(dragSeed);
  }

  function removeDragSeed() {
    if (dragSeed) {
      dragSeed.remove();
      dragSeed = null;
    }
  }

  // Hover identification for automata
  function setupAutomatonHover() {
    document.addEventListener('mouseover', (e) => {
      if (e.target.classList.contains('ca-pixel')) {
        const pixelElement = e.target;
        
        // Find which automaton this pixel belongs to
        const automaton = automatonInstances.find(instance => 
          Object.values(instance.pixels).includes(pixelElement)
        );
        
        if (automaton) {
          showHoverTooltip(e.clientX, e.clientY, `${automaton.customName || automaton.type.charAt(0).toUpperCase() + automaton.type.slice(1)} ${automaton.number}`);
        }
      }
    });

    document.addEventListener('mouseout', (e) => {
      if (e.target.classList.contains('ca-pixel')) {
        hideHoverTooltip();
      }
    });
  }

  function showHoverTooltip(x, y, text) {
    hideHoverTooltip();
    hoverTooltip = document.createElement('div');
    hoverTooltip.className = 'ca-hover-tooltip';
    hoverTooltip.textContent = text;
    hoverTooltip.style.left = x + 'px';
    hoverTooltip.style.top = y + 'px';
    document.body.appendChild(hoverTooltip);
  }

  function hideHoverTooltip() {
    if (hoverTooltip) {
      hoverTooltip.remove();
      hoverTooltip = null;
    }
  }

  // Initialize all functionality
  setupDragAndDrop();
  setupAutomatonHover();

  // Make functions available globally
  window.launchAutomaton = launchAutomaton;
  window.deactivateAutomaton = deactivateAutomaton;
  window.deactivateAllAutomatons = deactivateAllAutomatons;
  window.renameAutomaton = renameAutomaton;
  window.hideRenameModal = hideRenameModal;
  window.saveRename = saveRename;
  window.showCAInfo = showCAInfo;
  window.hideCAInfo = hideCAInfo;
  window.showAutomatonID = showAutomatonID;

  // Add keyboard support for rename modal and automata menu
  document.addEventListener('keydown', (e) => {
    const modal = document.getElementById('ca-rename-modal');
    const caMenu = document.getElementById('ca-menu');
    
    // Handle rename modal
    if (modal.style.display === 'flex') {
      if (e.key === 'Enter') {
        e.preventDefault();
        saveRename();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        hideRenameModal();
      }
    }
    // Handle automata menu - close on Escape
    else if (caMenu.style.display === 'flex' && e.key === 'Escape') {
      e.preventDefault();
      caMenu.style.display = 'none';
    }
  });

  function launchAutomaton(type, x = null, y = null, customName = null) {
    // Check if we've reached the maximum limit of 3 automata
    if (automatonInstances.length >= 3) {
      print('automata: maximum of 3 automata allowed for optimal performance');
      return null;
    }
    
    automatonCounters[type]++;
    const id = `${type}-${automatonCounters[type]}`;
    console.log('launchAutomaton called:', type, 'Current count:', automatonInstances.length);
    
    let newInstance;
    switch (type) {
      case 'worm':
        try {
          newInstance = new WormAutomaton();
        } catch (error) {
          console.error('Error creating WormAutomaton:', error);
          return null;
        }
        break;
      case 'flower':
        console.log('Creating FlowerAutomaton...');
        newInstance = new FlowerAutomaton();
        break;
      case 'moss':
        console.log('Creating MossAutomaton...');
        newInstance = new MossAutomaton();
        break;
    }
    
    newInstance.id = id;
    newInstance.type = type;
    newInstance.number = automatonCounters[type];
    newInstance.customName = customName; // Set custom name if provided
    
    let spawnLocation;
    if (x !== null && y !== null) {
      spawnLocation = { x, y };
      console.log('Using provided spawn location:', spawnLocation);
    } else {
      spawnLocation = findSafeSpawnLocation();
      console.log('Generated spawn location:', spawnLocation);
    }
    
    console.log('Calling spawn on', newInstance.type, 'with location:', spawnLocation);
    newInstance.spawn(spawnLocation.x, spawnLocation.y);
    automatonInstances.push(newInstance);
    
    console.log('Automaton spawned successfully. Total count:', automatonInstances.length);
    
    updateActiveList();
    return newInstance;
  }

  function updateAutomatonPopups() {
    automatonInstances.forEach(instance => {
      if (instance.idPopup && instance.idPopup.parentNode) {
        const coords = getAutomatonCoordinates(instance);
        instance.idPopup.style.left = coords.x + 'px';
        instance.idPopup.style.top = (coords.y - 30) + 'px';
      }
    });
  }

  // Update popup positions periodically
  setInterval(updateAutomatonPopups, 100);

  function renameAutomaton(id) {
    console.log('renameAutomaton called with id:', id);
    currentRenameId = id;
    const instance = automatonInstances.find(inst => inst.id === id);
    if (!instance) {
      console.log('Instance not found for id:', id);
      return;
    }

    const modal = document.getElementById('ca-rename-modal');
    const input = document.getElementById('ca-rename-input');
    
    const currentName = instance.customName || `${instance.type.charAt(0).toUpperCase() + instance.type.slice(1)} ${instance.number}`;
    console.log('Setting input value to:', currentName);
    
    // Set up the modal
    input.value = currentName;
    input.removeAttribute('readonly');
    input.removeAttribute('disabled');
    
    modal.style.display = 'flex';
    
    // Focus and select the input after a brief delay
    setTimeout(() => {
      input.focus();
      input.select();
    }, 100);
  }

  function hideRenameModal() {
    const modal = document.getElementById('ca-rename-modal');
    modal.style.display = 'none';
    currentRenameId = null;
  }

  function saveRename() {
    console.log('saveRename called');
    if (!currentRenameId) {
      console.log('No currentRenameId');
      return;
    }
    
    const input = document.getElementById('ca-rename-input');
    const newName = input.value.trim();
    console.log('Input value:', input.value, 'Trimmed:', newName);
    
    if (newName) {
      const instance = automatonInstances.find(inst => inst.id === currentRenameId);
      if (instance) {
        const oldName = instance.customName || `${capitalizeFirst(instance.type)} ${instance.number}`;
        console.log('Renaming from:', oldName, 'to:', newName);
        
        // Direct rename
        console.log('Renaming directly');
        instance.customName = newName;
        
        // Update the ID popup if it's currently displayed
        if (instance.idPopup && instance.idPopup.parentNode) {
          instance.idPopup.textContent = newName;
        }
        
        updateActiveList();
      } else {
        console.log('Instance not found for ID:', currentRenameId);
      }
    } else {
      console.log('New name is empty');
    }
    
    hideRenameModal();
  }

  function deactivateAutomaton(id) {
    const instance = automatonInstances.find(inst => inst.id === id);
    if (instance) {
      // Get the display name before deactivating
      const displayName = instance.customName || `${capitalizeFirst(instance.type)} ${instance.number}`;
      
      // Remove ID popup if it exists
      if (instance.idPopup && instance.idPopup.parentNode) {
        instance.idPopup.remove();
        instance.idPopup = null;
      }
      
      // Remove scope icon active state
      const scopeIcon = document.querySelector(`[data-automaton-id="${id}"] .scope-icon`);
      if (scopeIcon) {
        scopeIcon.classList.remove('active');
      }
      
      // Mark as inactive immediately and start the disappearing animation
      instance.isActive = false;
      if (typeof instance.creativeExploration === 'function') {
        instance.creativeExploration();
      }
      
      // Remove from instances array immediately so it disappears from the menu
      automatonInstances = automatonInstances.filter(inst => inst.id !== id);
      updateActiveList();
    }
  }

  function deactivateAllAutomatons(silent = false) {
    // Normal deactivation behavior
    if (automatonInstances.length === 0) {
      if (!silent) showMessage("No automata are currently active.");
      return;
    }
    
    const count = automatonInstances.length;
    
    // Remove all ID popups and start disappearing animations
    automatonInstances.forEach(instance => {
      if (instance.idPopup && instance.idPopup.parentNode) {
        instance.idPopup.remove();
        instance.idPopup = null;
      }
      
      // Mark as inactive and start disappearing animation
      instance.isActive = false;
      if (typeof instance.creativeExploration === 'function') {
        instance.creativeExploration();
      }
    });
    
    // Clear the instances array immediately so they disappear from the menu
    automatonInstances = [];
    updateActiveList();
  }

  function updateActiveList() {
    const activeContainer = document.getElementById('active-automatons');
    const deactivateAllBtn = document.querySelector('.deactivate-all');
    const countElement = document.getElementById('ca-count');
    
    if (automatonInstances.length === 0) {
      activeContainer.innerHTML = '<div class="ca-menu-item">None</div>';
      deactivateAllBtn.classList.add('disabled');
      countElement.textContent = '(0)';
    } else {
      activeContainer.innerHTML = '';
      automatonInstances.forEach(instance => {
        const item = document.createElement('div');
        item.className = 'ca-menu-item active';
        item.setAttribute('data-automaton-id', instance.id);
        
        const displayName = instance.customName || `${instance.type.charAt(0).toUpperCase() + instance.type.slice(1)} ${instance.number}`;
        
        // Get coordinates for this automaton
        const coords = getAutomatonCoordinates(instance);
        
        item.innerHTML = `
          <div class="menu-item-content">
            <span class="menu-item-name">${displayName}</span>
          </div>
          <div class="ca-item-controls">
            <div class="scope-icon" data-action="show-id" title="Show ID"></div>
            <button class="ca-rename-btn" title="Rename">✎</button>
            <button class="ca-delete-btn" title="Delete">×</button>
          </div>
        `;
        
        // Add event listeners
        const scopeIcon = item.querySelector('.scope-icon');
        scopeIcon.onclick = (e) => {
          e.stopPropagation();
          // Execute directly
          showAutomatonID(instance);
        };
        
        const renameBtn = item.querySelector('.ca-rename-btn');
        renameBtn.onclick = (e) => {
          e.stopPropagation();
          // Execute directly
          renameAutomaton(instance.id);
        };
        
        const deleteBtn = item.querySelector('.ca-delete-btn');
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          // Execute directly
          deactivateAutomaton(instance.id);
        };
        
        activeContainer.appendChild(item);
        
        // Restore scope icon active state if this automaton has an active ID popup
        if (instance.idPopup && document.body.contains(instance.idPopup)) {
          scopeIcon.classList.add('active');
        }
      });
      deactivateAllBtn.classList.remove('disabled');
      countElement.textContent = `(${automatonInstances.length})`;
    }
  }

  function getAutomatonCoordinates(instance) {
    try {
      if (!instance) {
        console.error('getAutomatonCoordinates: No instance provided');
        return { x: 50, y: 50 }; // Fallback coordinates
      }

      // Get the center coordinates of the automaton
      if (instance.pixels && Object.keys(instance.pixels).length > 0) {
        const pixelElements = Object.values(instance.pixels).filter(p => p && p.parentNode);
        if (pixelElements.length > 0) {
          // Calculate center based on pixel positions
          let totalX = 0, totalY = 0, count = 0;
          
          pixelElements.forEach(pixel => {
            try {
              const rect = pixel.getBoundingClientRect();
              totalX += rect.left + rect.width / 2;
              totalY += rect.top + rect.height / 2;
              count++;
            } catch (e) {
              console.warn('Error getting pixel bounds:', e);
            }
          });
          
          if (count > 0) {
            const centerX = Math.round(totalX / count);
            const centerY = Math.round(totalY / count);
            
            return { x: centerX, y: centerY };
          }
        }
      }
      
      // Fallback to instance position if available
      return { 
        x: Math.round(instance.x || 50), 
        y: Math.round(instance.y || 50) 
      };
    } catch (error) {
      console.error('Error in getAutomatonCoordinates:', error);
      return { x: 50, y: 50 }; // Safe fallback
    }
  }

  function showAutomatonID(instance) {
    try {
      if (!instance) {
        console.error('showAutomatonID: No instance provided');
        return;
      }

      const scopeIcon = document.querySelector(`[data-automaton-id="${instance.id}"] .scope-icon`);
      
      // Toggle the active state
      if (instance.idPopup && instance.idPopup.parentNode) {
        // Remove existing popup and deactivate scope icon
        instance.idPopup.remove();
        instance.idPopup = null;
        if (scopeIcon) {
          scopeIcon.classList.remove('active');
        }
        return;
      }
      
      // Create new ID popup
      const popup = document.createElement('div');
      popup.className = 'automaton-id-popup';
      popup.textContent = instance.customName || `${instance.type.charAt(0).toUpperCase() + instance.type.slice(1)} ${instance.number}`;
      
      // Position popup at automaton center
      const coords = getAutomatonCoordinates(instance);
      if (coords) {
        popup.style.left = coords.x + 'px';
        popup.style.top = (coords.y - 30) + 'px';
      } else {
        // Fallback positioning if coordinates can't be determined
        popup.style.left = '50px';
        popup.style.top = '50px';
      }
      
      document.body.appendChild(popup);
      
      // Store popup reference with instance for movement updates
      instance.idPopup = popup;
      
      // Activate scope icon
      if (scopeIcon) {
        scopeIcon.classList.add('active');
      }
      
      // No auto-removal - stays until manually toggled
    } catch (error) {
      console.error('Error in showAutomatonID:', error);
      throw error; // Re-throw so the calling code can handle it
    }
  }

  function showMessage(message) {
    // Create temporary message popup
    const popup = document.createElement('div');
    popup.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(139, 0, 0, 0.9);
      color: white;
      padding: 15px 25px;
      border-radius: 8px;
      border: 1px solid #8b0000;
      z-index: 10001;
      font-size: 14px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    `;
    popup.textContent = message;
    document.body.appendChild(popup);
    
    setTimeout(() => {
      if (popup.parentNode) {
        popup.parentNode.removeChild(popup);
      }
    }, 2000);
  }
  
  function findSafeSpawnLocation() {
    const gridWidth = Math.floor(window.innerWidth / 6);
    const gridHeight = Math.floor(window.innerHeight / 6);
    const minDistance = 30; // Reduced minimum distance to allow more spawn options
    
    // Much safer spawn area - center 60% of screen with margins
    const marginX = Math.floor(gridWidth * 0.2); // 20% margin from each side
    const marginY = Math.floor(gridHeight * 0.15); // 15% margin from top/bottom
    const safeLeft = marginX;
    const safeRight = gridWidth - marginX;
    const safeTop = marginY;
    const safeBottom = gridHeight - marginY;
    
    console.log('Safe spawn area:', { safeLeft, safeRight, safeTop, safeBottom });
    
    let attempts = 0;
    let x, y;
    
    do {
      // Always spawn in the safe central area
      x = Math.floor(Math.random() * (safeRight - safeLeft)) + safeLeft;
      y = Math.floor(Math.random() * (safeBottom - safeTop)) + safeTop;
      
      console.log(`Spawn attempt ${attempts + 1}: (${x}, ${y})`);
      attempts++;
    } while (attempts < 30 && !isLocationSafe(x, y, minDistance));
    
    // Ensure coordinates are valid even if no safe location was found
    if (attempts >= 30) {
      console.log('Could not find safe location, using fallback');
      x = Math.floor(gridWidth / 2);
      y = Math.floor(gridHeight / 2);
    }
    
    console.log('Final spawn location:', { x, y });
    return { x, y };
  }
  
  function isLocationSafe(x, y, minDistance) {
    for (let instance of automatonInstances) {
      if (instance && instance.center) {
        const distance = Math.sqrt(
          Math.pow(x - instance.center.x, 2) + 
          Math.pow(y - instance.center.y, 2)
        );
        if (distance < minDistance) {
          return false;
        }
      }
    }
    return true;
  }

  // Info Modal Functions
  function showCAInfo() {
    console.log('showCAInfo called');
    const modal = document.getElementById('ca-info-modal');
    console.log('Modal element:', modal);
    if (modal) {
      modal.style.display = 'flex';
      console.log('Modal display set to flex');
    } else {
      console.error('Modal element not found');
    }
  }

  function hideCAInfo() {
    const modal = document.getElementById('ca-info-modal');
    modal.style.display = 'none';
  }

  function makeModalDraggable() {
    console.log('makeModalDraggable called');
    const modal = document.getElementById('ca-info-modal');
    console.log('Modal found for dragging:', modal);
    
    // Check if already initialized
    if (modal && modal.dataset.draggableInitialized === 'true') {
      console.log('Modal already initialized');
      return;
    }
    if (modal) {
      modal.dataset.draggableInitialized = 'true';
      console.log('Initializing modal dragging');
    } else {
      console.error('Modal not found for dragging initialization');
      return;
    }
    
    let isDragging = false;
    let isResizing = false;
    let dragStartTime = 0;
    let resizeMode = null;
    let startX, startY, startLeft, startTop, startWidth, startHeight;

    // Set initial position in pixels to avoid transform issues
    function initializePosition() {
      if (modal.style.left === '' || modal.style.left.includes('%')) {
        const rect = modal.getBoundingClientRect();
        modal.style.left = rect.left + 'px';
        modal.style.top = rect.top + 'px';
        modal.style.transform = 'none';
      }
    }

    // Header drag functionality
    const header = document.getElementById('ca-modal-header');
    if (header) {
      header.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('ca-info-modal-close')) return;
        
        initializePosition();
        isDragging = true;
        dragStartTime = Date.now();
        
        startX = e.clientX;
        startY = e.clientY;
        startLeft = parseInt(modal.style.left);
        startTop = parseInt(modal.style.top);
        
        e.preventDefault();
        e.stopPropagation();
      });
    }

    // Edge resize functionality
    modal.addEventListener('mousedown', (e) => {
      // Skip if clicking on header (already handled) or close button
      if (e.target.closest('#ca-modal-header') || 
          e.target.classList.contains('ca-info-modal-close')) return;
      
      const rect = modal.getBoundingClientRect();
      const threshold = 10;
      const nearLeft = e.clientX - rect.left < threshold;
      const nearRight = rect.right - e.clientX < threshold;
      const nearTop = e.clientY - rect.top < threshold;
      const nearBottom = rect.bottom - e.clientY < threshold;
      
      if (nearLeft || nearRight || nearTop || nearBottom) {
        initializePosition();
        isResizing = true;
        dragStartTime = Date.now();
        
        resizeMode = '';
        if (nearTop) resizeMode += 'n';
        if (nearBottom) resizeMode += 's';
        if (nearLeft) resizeMode += 'w';
        if (nearRight) resizeMode += 'e';
        
        startX = e.clientX;
        startY = e.clientY;
        startLeft = parseInt(modal.style.left);
        startTop = parseInt(modal.style.top);
        startWidth = modal.offsetWidth;
        startHeight = modal.offsetHeight;
        
        e.preventDefault();
        e.stopPropagation();
      }
    });

    // Update cursor for resize handles
    modal.addEventListener('mousemove', (e) => {
      if (isDragging || isResizing) return;
      
      const rect = modal.getBoundingClientRect();
      const threshold = 10;
      const nearLeft = e.clientX - rect.left < threshold;
      const nearRight = rect.right - e.clientX < threshold;
      const nearTop = e.clientY - rect.top < threshold;
      const nearBottom = rect.bottom - e.clientY < threshold;
      
      if ((nearTop && nearLeft) || (nearBottom && nearRight)) {
        modal.style.cursor = 'nw-resize';
      } else if ((nearTop && nearRight) || (nearBottom && nearLeft)) {
        modal.style.cursor = 'ne-resize';
      } else if (nearTop || nearBottom) {
        modal.style.cursor = 'n-resize';
      } else if (nearLeft || nearRight) {
        modal.style.cursor = 'e-resize';
      } else {
        modal.style.cursor = 'default';
      }
    });

    // Global mouse move handler
    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        
        modal.style.left = (startLeft + deltaX) + 'px';
        modal.style.top = (startTop + deltaY) + 'px';
      } else if (isResizing) {
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        
        let newWidth = startWidth;
        let newHeight = startHeight;
        let newLeft = startLeft;
        let newTop = startTop;
        
        if (resizeMode.includes('e')) {
          newWidth = Math.max(300, startWidth + deltaX);
        }
        if (resizeMode.includes('w')) {
          newWidth = Math.max(300, startWidth - deltaX);
          newLeft = startLeft + (startWidth - newWidth);
        }
        if (resizeMode.includes('s')) {
          newHeight = Math.max(200, startHeight + deltaY);
        }
        if (resizeMode.includes('n')) {
          newHeight = Math.max(200, startHeight - deltaY);
          newTop = startTop + (startHeight - newHeight);
        }
        
        modal.style.width = newWidth + 'px';
        modal.style.height = newHeight + 'px';
        modal.style.left = newLeft + 'px';
        modal.style.top = newTop + 'px';
      }
    });

    // Global mouse up handler
    document.addEventListener('mouseup', (e) => {
      const wasDragOperation = isDragging || isResizing;
      const operationDuration = Date.now() - dragStartTime;
      
      isDragging = false;
      isResizing = false;
      resizeMode = null;
      modal.style.cursor = 'default';
      
      // Prevent clicks from closing modal if we just finished a drag operation
      if (wasDragOperation && operationDuration > 50) {
        e.stopPropagation();
      }
    });

    // Prevent modal clicks from propagating
    modal.addEventListener('click', (e) => {
      e.stopPropagation();
    });
  }

  // Close modal only when clicking outside the modal entirely
  document.addEventListener('click', (e) => {
    const modal = document.getElementById('ca-info-modal');
    
    // Only close if modal is visible and click is completely outside the modal
    if (modal.style.display !== 'none' && !modal.contains(e.target)) {
      hideCAInfo();
    }
  });

  // Prevent modal content clicks from propagating to document
  document.addEventListener('click', (e) => {
    const modal = document.getElementById('ca-info-modal');
    if (modal.contains(e.target) && e.target !== modal) {
      e.stopPropagation();
    }
  });

  // Vim editor event handlers
  const vimEditor = document.getElementById('vim-editor');
  const vimClose = vimEditor.querySelector('.vim-close');
  const vimTextarea = vimEditor.querySelector('.vim-textarea');
  
  // Close vim editor
  vimClose.addEventListener('click', () => {
    closeVimEditor();
  });
  
  // Make vim editor draggable and resizable
  vimEditor.addEventListener('mousedown', () => bringToFront(vimEditor));
  attachEdgeResize(vimEditor, {edge: 10, minW: 400, minH: 300});
  
  // Make vim draggable by header
  const vimHeader = vimEditor.querySelector('.vim-header');
  let vimDragging = false, vimOffX = 0, vimOffY = 0;
  
  vimHeader.addEventListener('mousedown', e => {
    // Don't drag when resizing
    const cur = getComputedStyle(vimEditor).cursor;
    if (/-resize$/.test(cur) || vimEditor.dataset.resizing === '1') return;
    
    vimDragging = true;
    vimOffX = e.clientX - vimEditor.offsetLeft;
    vimOffY = e.clientY - vimEditor.offsetTop;
    document.body.style.userSelect = 'none';
  });
  
  document.addEventListener('mousemove', e => {
    if (!vimDragging) return;
    vimEditor.style.left = (e.clientX - vimOffX) + 'px';
    vimEditor.style.top = (e.clientY - vimOffY) + 'px';
  });
  
  document.addEventListener('mouseup', () => {
    if (!vimDragging) return;
    vimDragging = false;
    document.body.style.userSelect = '';
  });

  // Track file modifications
  vimTextarea.addEventListener('input', () => {
    if (vimMode === 'INSERT') {
      vimFileModified = true;
      updateVimStatusInfo();
    }
  });

  // Update status info on cursor movement
  vimTextarea.addEventListener('click', updateVimStatusInfo);
  vimTextarea.addEventListener('keyup', updateVimStatusInfo);

  // Make sidebar resizable
  const resizeHandle = document.querySelector('#vim-editor .resize-handle');
  const sidebar = document.querySelector('#vim-editor .vim-sidebar');
  let isResizing = false;
  
  resizeHandle.addEventListener('mousedown', (e) => {
    isResizing = true;
    document.body.style.cursor = 'col-resize';
    document.body.style.userSelect = 'none';
    e.preventDefault();
  });
  
  document.addEventListener('mousemove', (e) => {
    if (!isResizing) return;
    
    const vimEditor = document.getElementById('vim-editor');
    const rect = vimEditor.getBoundingClientRect();
    const newWidth = e.clientX - rect.left;
    
    // Constrain width between min and max
    const minWidth = 150;
    const maxWidth = Math.min(400, rect.width * 0.6); // Max 60% of vim editor width
    const constrainedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
    
    sidebar.style.width = constrainedWidth + 'px';
  });
  
  document.addEventListener('mouseup', () => {
    if (isResizing) {
      isResizing = false;
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
    }
  });
  
  // Vim keybindings
  vimTextarea.addEventListener('keydown', (e) => {
    if (vimMode === 'INSERT') {
      if (e.key === 'Escape') {
        e.preventDefault();
        setVimMode('NORMAL');
      }
    } else if (vimMode === 'NORMAL') {
      if (e.key === 'i') {
        e.preventDefault();
        setVimMode('INSERT');
      } else if (e.key === ':') {
        e.preventDefault();
        vimCommandBuffer = '';
        setVimMode('COMMAND');
      } else if (e.key === 'a') {
        e.preventDefault();
        setVimMode('INSERT');
        // Move cursor to end of current position
      } else if (e.key === 'o') {
        e.preventDefault();
        setVimMode('INSERT');
        // Add new line and go to insert mode
        const textarea = e.target;
        const cursorPos = textarea.selectionStart;
        const lineEnd = textarea.value.indexOf('\n', cursorPos);
        const insertPos = lineEnd === -1 ? textarea.value.length : lineEnd;
        textarea.value = textarea.value.slice(0, insertPos) + '\n' + textarea.value.slice(insertPos);
        textarea.setSelectionRange(insertPos + 1, insertPos + 1);
      } else if (e.key === 'A') {
        e.preventDefault();
        setVimMode('INSERT');
        // Move to end of line
        const textarea = e.target;
        const cursorPos = textarea.selectionStart;
        const lineEnd = textarea.value.indexOf('\n', cursorPos);
        const endPos = lineEnd === -1 ? textarea.value.length : lineEnd;
        textarea.setSelectionRange(endPos, endPos);
      } else if (e.key === 'O') {
        e.preventDefault();
        setVimMode('INSERT');
        // Add new line above and go to insert mode
        const textarea = e.target;
        const cursorPos = textarea.selectionStart;
        const textBeforeCursor = textarea.value.substring(0, cursorPos);
        const lastNewline = textBeforeCursor.lastIndexOf('\n');
        const lineStart = lastNewline === -1 ? 0 : lastNewline + 1;
        textarea.value = textarea.value.slice(0, lineStart) + '\n' + textarea.value.slice(lineStart);
        textarea.setSelectionRange(lineStart + 1, lineStart + 1);
      } else if (e.key === 'u') {
        e.preventDefault();
        showVimMessage('Undo not supported in this simplified vim');
      } else if (e.key === 'r' && e.ctrlKey) {
        e.preventDefault();
        showVimMessage('Redo not supported in this simplified vim');
      } else if (e.key === 'x') {
        e.preventDefault();
        showVimMessage('Delete character not supported in this simplified vim');
      } else if (e.key === 'd') {
        e.preventDefault();
        showVimMessage('Delete commands not supported in this simplified vim');
      } else if (e.key === 'y') {
        e.preventDefault();
        showVimMessage('Yank (copy) not supported in this simplified vim');
      } else if (e.key === 'p') {
        e.preventDefault();
        showVimMessage('Paste not supported in this simplified vim');
      } else if (e.key === '/') {
        e.preventDefault();
        showVimMessage('Search not supported in this simplified vim');
      } else if (e.key === 'h' || e.key === 'j' || e.key === 'k' || e.key === 'l') {
        e.preventDefault();
        showVimMessage('Arrow key navigation not supported - use mouse or arrow keys instead');
      } else if (e.key === 'g') {
        e.preventDefault();
        showVimMessage('Go to commands not supported in this simplified vim');
      } else if (e.key === 'v') {
        e.preventDefault();
        showVimMessage('Visual mode not supported in this simplified vim');
      } else if (e.key === 'w' || e.key === 'b' || e.key === 'e') {
        e.preventDefault();
        showVimMessage('Word navigation not supported in this simplified vim');
      } else if (e.key === '0' || e.key === '$') {
        e.preventDefault();
        showVimMessage('Line navigation not supported in this simplified vim');
      } else if (e.key === 'G') {
        e.preventDefault();
        showVimMessage('Go to line not supported in this simplified vim');
      } else if (e.key === 'n' || e.key === 'N') {
        e.preventDefault();
        showVimMessage('Search navigation not supported in this simplified vim');
      }
    } else if (vimMode === 'COMMAND') {
      if (e.key === 'Escape') {
        e.preventDefault();
        vimCommandBuffer = '';
        setVimMode('NORMAL');
      } else if (e.key === 'Enter') {
        e.preventDefault();
        executeVimCommand(vimCommandBuffer);
      } else if (e.key === 'Backspace') {
        e.preventDefault();
        vimCommandBuffer = vimCommandBuffer.slice(0, -1);
        setVimMode('COMMAND');
      } else if (e.key.length === 1) {
        e.preventDefault();
        vimCommandBuffer += e.key;
        setVimMode('COMMAND');
      }
    }
  });
});

document.getElementById('terminal-window')
  .addEventListener('mousedown', () => bringToFront(document.getElementById('terminal-window')));

document.getElementById('help-modal')
  .addEventListener('mousedown', () => bringToFront(document.getElementById('help-modal')));


// Draggable terminal window (no title bar)
(function() {
  const win = document.getElementById('terminal-window');
  let dragging = false, offX = 0, offY = 0;

  win.addEventListener('mousedown', e => {
    // ⛔ Do not start a drag when resizing (edge/corner or active resize)
    const cur = getComputedStyle(win).cursor;
    if (/-resize$/.test(cur) || win.dataset.resizing === '1') return;

    // Don't start drag if clicking inside interactive elements
    if (e.target.closest('.prompt-input') ||
        e.target.closest('.cli-buttons')  ||
        e.target.closest('#help-modal')) return;

    dragging = true;
    offX = e.clientX - win.offsetLeft;
    offY = e.clientY - win.offsetTop;
    document.body.style.userSelect = 'none';
    
    // Disable transitions for smooth dragging
    win.style.transition = 'none';
  });

  document.addEventListener('mousemove', e => {
    if (!dragging) return;
    win.style.left = (e.clientX - offX) + 'px';
    win.style.top  = (e.clientY - offY) + 'px';
  });

  document.addEventListener('mouseup', () => {
    if (!dragging) return;
    dragging = false;
    document.body.style.userSelect = '';
    
    // Re-enable transitions
    win.style.transition = '';
  });
})();




// light up on real keypress
document.addEventListener('keydown', e => {
  const keyDiv = document.querySelector(`.key[data-key="${e.code}"]`);
  if (keyDiv) keyDiv.classList.add('active');
  // sync CapsLock visual state from physical keyboard
  const capsOn = e.getModifierState && e.getModifierState('CapsLock');
  updateCapsVisual(capsOn);
});
document.addEventListener('keyup', e => {
  const keyDiv = document.querySelector(`.key[data-key="${e.code}"]`);
  if (keyDiv) keyDiv.classList.remove('active');
  // also update on keyup in case state changed
  const capsOn = e.getModifierState && e.getModifierState('CapsLock');
  updateCapsVisual(capsOn);
});

// RE-SIZE

function attachEdgeResize(el, {edge = 10, minW = 360, minH = 220} = {}) {
  let mode = null, startX = 0, startY = 0, startW = 0, startH = 0, startLeft = 0, startTop = 0;

  function setCursor(e) {
    const r = el.getBoundingClientRect();
    const x = e.clientX - r.left, y = e.clientY - r.top;
    const onW = x < edge, onE = r.width  - x < edge;
    const onN = y < edge, onS = r.height - y < edge;

    // corners first (like macOS/Windows)
    let cursor = '', side = '';
    if ((onN && onW) || (onS && onE)) { cursor = 'nwse-resize'; side = onN ? 'nw' : 'se'; }
    else if ((onN && onE) || (onS && onW)) { cursor = 'nesw-resize'; side = onN ? 'ne' : 'sw'; }
    else if (onW || onE) { cursor = 'ew-resize'; side = onW ? 'w' : 'e'; }
    else if (onN || onS) { cursor = 'ns-resize'; side = onN ? 'n' : 's'; }

    el.style.cursor = cursor || '';
    el.dataset.edgeSide = side; // '', 'n','s','e','w','ne','nw','se','sw'
  }

  el.addEventListener('mousemove', setCursor);
  el.addEventListener('mouseleave', () => { if (!mode) el.style.cursor = ''; });

  el.addEventListener('mousedown', e => {
    const c = getComputedStyle(el).cursor;
    if (!/-resize$/.test(c)) return;             // only start on a resize edge/corner
    e.preventDefault();

    mode = el.dataset.edgeSide;
    const r = el.getBoundingClientRect();
    startX = e.clientX;   startY = e.clientY;
    startW = r.width;     startH = r.height;
    startLeft = r.left + window.scrollX;
    startTop  = r.top  + window.scrollY;

    el.dataset.resizing = '1';
    document.body.style.userSelect = 'none';
    
    // Disable transitions for smooth resizing
    el.style.transition = 'none';
  });

  document.addEventListener('mousemove', e => {
    if (!mode) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;

    const clamp = (v, min) => Math.max(min, v);

    if (mode.includes('e')) el.style.width = clamp(startW + dx, minW) + 'px';
    if (mode.includes('s')) el.style.height = clamp(startH + dy, minH) + 'px';

    if (mode.includes('w')) {
      const nw = clamp(startW - dx, minW);
      el.style.width = nw + 'px';
      el.style.left  = (startLeft + startW - nw) + 'px'; // keep right edge fixed
    }
    if (mode.includes('n')) {
      const nh = clamp(startH - dy, minH);
      el.style.height = nh + 'px';
      el.style.top    = (startTop + startH - nh) + 'px'; // keep bottom edge fixed
    }
  });

  document.addEventListener('mouseup', () => {
    if (!mode) return;
    mode = null;
    el.dataset.resizing = '';
    document.body.style.userSelect = '';
    el.style.cursor = '';
    
    // Re-enable transitions
    el.style.transition = '';
  });
}

// Specialized resize for keyboard panel that maintains aspect ratio and scales content
function attachKeyboardResize(panel, keyboard, {edge = 10, minScale = 0.5, maxScale = 2.0} = {}) {
  let mode = null, startX = 0, startY = 0, startScale = 1, startLeft = 0, startTop = 0;
  
  // Get initial dimensions and aspect ratio
  const baseWidth = parseFloat(keyboard.dataset.baseW);
  const baseHeight = parseFloat(keyboard.dataset.baseH);
  const aspectRatio = parseFloat(keyboard.dataset.aspectRatio);
  
  function setCursor(e) {
    if (panel.dataset.resizing === '1') return; // Don't change cursor during resize
    
    const r = panel.getBoundingClientRect();
    const x = e.clientX - r.left, y = e.clientY - r.top;
    const onW = x < edge, onE = r.width  - x < edge;
    const onN = y < edge, onS = r.height - y < edge;

    // Only allow corner resize to maintain aspect ratio
    let cursor = '', side = '';
    if ((onN && onW) || (onS && onE)) { 
      cursor = 'nwse-resize'; 
      side = onN ? 'nw' : 'se'; 
    } else if ((onN && onE) || (onS && onW)) { 
      cursor = 'nesw-resize'; 
      side = onN ? 'ne' : 'sw'; 
    }

    panel.style.cursor = cursor || '';
    panel.dataset.edgeSide = side;
  }

  panel.addEventListener('mousemove', setCursor);
  panel.addEventListener('mouseleave', () => { 
    if (!mode) panel.style.cursor = ''; 
  });

  panel.addEventListener('mousedown', e => {
    const c = getComputedStyle(panel).cursor;
    if (!/-resize$/.test(c)) return;
    e.preventDefault();
    e.stopPropagation(); // Prevent drag from starting

    mode = panel.dataset.edgeSide;
    const r = panel.getBoundingClientRect();
    startX = e.clientX;   
    startY = e.clientY;
    startLeft = r.left + window.scrollX;
    startTop  = r.top  + window.scrollY;
    
    // Calculate current scale from transform
    const transform = getComputedStyle(keyboard).transform;
    if (transform && transform !== 'none') {
      const matrix = new DOMMatrix(transform);
      startScale = matrix.a; // scaleX value
    } else {
      startScale = 1;
    }

    panel.dataset.resizing = '1';
    document.body.style.userSelect = 'none';
  });

  document.addEventListener('mousemove', e => {
    if (!mode) return;
    
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    
    // Calculate scale change based on diagonal movement
    let scaleChange = 1;
    if (mode === 'se') {
      scaleChange = 1 + (dx + dy) / (baseWidth + baseHeight);
    } else if (mode === 'nw') {
      scaleChange = 1 - (dx + dy) / (baseWidth + baseHeight);
    } else if (mode === 'ne') {
      scaleChange = 1 + (dx - dy) / (baseWidth + baseHeight);
    } else if (mode === 'sw') {
      scaleChange = 1 - (dx - dy) / (baseWidth + baseHeight);
    }
    
    const newScale = Math.max(minScale, Math.min(maxScale, startScale * scaleChange));
    
    // Apply transform to keyboard (centered scaling)
    keyboard.style.transform = `scale(${newScale})`;
    
    // Calculate scaled dimensions
    const scaledWidth = baseWidth * newScale;
    const scaledHeight = baseHeight * newScale;
    
    // Scale the gap proportionally with the keyboard size
    const baseGapSize = 10; // 10px gap at normal scale (1.0)
    const scaledGap = baseGapSize * newScale;
    
    // Set panel size with proportionally scaled gap
    panel.style.width = (scaledWidth + scaledGap * 2) + 'px';
    panel.style.height = (scaledHeight + scaledGap * 2) + 'px';
    
    // Adjust position for corner resizes to keep opposite corner fixed
    if (mode.includes('n')) {
      const heightDiff = (newHeight - baseHeight * startScale);
      panel.style.top = (startTop - heightDiff) + 'px';
    }
    if (mode.includes('w')) {
      const widthDiff = (newWidth - baseWidth * startScale);
      panel.style.left = (startLeft - widthDiff) + 'px';
    }
  });

  document.addEventListener('mouseup', () => {
    if (!mode) return;
    mode = null;
    panel.dataset.resizing = '';
    document.body.style.userSelect = '';
    panel.style.cursor = '';
  });
}


// Attach to both windows
document.addEventListener('DOMContentLoaded', () => {
  attachEdgeResize(document.getElementById('terminal-window'), {edge: 10, minW: 360, minH: 220});
  attachEdgeResize(document.getElementById('help-modal'),     {edge: 10, minW: 340, minH: 220});
  
  // Initialize keyboard with aspect-ratio resize
  const kbPanel = document.getElementById('keyboard-panel');
  const kb = document.getElementById('keyboard');
  if (kb && kbPanel) {
    // Store initial dimensions and aspect ratio
    const initialRect = kb.getBoundingClientRect();
    kb.dataset.baseW = initialRect.width;
    kb.dataset.baseH = initialRect.height;
    kb.dataset.aspectRatio = initialRect.width / initialRect.height;
    
    // Apply initial 77% scale
    const initialScale = 0.77;
    kb.style.transform = `scale(${initialScale})`;
    
    // Update panel size to match scaled content
    const scaledWidth = initialRect.width * initialScale;
    const scaledHeight = initialRect.height * initialScale;
    const baseGapSize = 10;
    const scaledGap = baseGapSize * initialScale;
    
    kbPanel.style.width = (scaledWidth + scaledGap * 2) + 'px';
    kbPanel.style.height = (scaledHeight + scaledGap * 2) + 'px';
    
    // Start keyboard as hidden/inactive
    kbPanel.classList.add('hidden');
    
    // Apply aspect-ratio constrained resize to keyboard panel
    attachKeyboardResize(kbPanel, kb);
  }
});

// Handle hover + click typing for on-screen keys
document.querySelectorAll('#keyboard .key').forEach(keyEl => {
  const code = keyEl.dataset.key;

  // keep it lit when hovering (CSS already covers this, but we want "active" class too)
  keyEl.addEventListener('mouseenter', () => {
    keyEl.classList.add('active');
  });
  keyEl.addEventListener('mouseleave', () => {
    keyEl.classList.remove('active');
  });

  // clicking should behave like pressing the physical key
  keyEl.addEventListener('click', () => {
    // Add visual feedback for key press
    keyEl.classList.add('pressed');
    setTimeout(() => keyEl.classList.remove('pressed'), 100);
    
    // Check if vim editor is active
    const vimEditor = document.getElementById('vim-editor');
    const vimTextarea = document.querySelector('#vim-editor .vim-textarea');
    const isVimActive = vimEditor.style.display !== 'none' && vimTextarea;
    
    // Determine target input - find the last/active prompt input
    let input;
    if (isVimActive) {
      input = vimTextarea;
    } else {
      // Find the last prompt input (the active one)
      const allPromptInputs = document.querySelectorAll('.prompt-input');
      input = allPromptInputs[allPromptInputs.length - 1];
      
      // If no prompt inputs found, try to find focused input or any input in terminal
      if (!input) {
        input = document.activeElement?.classList?.contains('prompt-input') ? document.activeElement : 
                document.querySelector('#terminal .prompt-input, #terminal input[type="text"]');
      }
    }
    
    if (!input) return;

    // Keep focus on input but do not force caret to end
    input.focus();

    const selStart = input.selectionStart ?? input.value.length;
    const selEnd   = input.selectionEnd   ?? selStart;

    if (code === 'Enter') {
      if (isVimActive && vimMode === 'INSERT') {
        // Insert newline in vim
        const before = input.value.slice(0, selStart);
        const after = input.value.slice(selEnd);
        input.value = before + '\n' + after;
        const pos = before.length + 1;
        input.setSelectionRange(pos, pos);
        input.dispatchEvent(new Event('input'));
      } else if (!isVimActive) {
        const e = new KeyboardEvent('keydown', { key: 'Enter', code: code });
        input.dispatchEvent(e);
      }
    } else if (code === 'Backspace') {
      if (selStart !== selEnd) {
        input.value = input.value.slice(0, selStart) + input.value.slice(selEnd);
        input.setSelectionRange(selStart, selStart);
      } else if (selStart > 0) {
        input.value = input.value.slice(0, selStart - 1) + input.value.slice(selEnd);
        const pos = selStart - 1;
        input.setSelectionRange(pos, pos);
      }
      input.dispatchEvent(new Event('input'));
      if (!isVimActive) {
        const wrap = input.parentElement;
        updateCursor(input, wrap);
      }
    } else if (code === 'Space') {
      const before = input.value.slice(0, selStart);
      const after  = input.value.slice(selEnd);
      input.value = before + ' ' + after;
      const pos = before.length + 1;
      input.setSelectionRange(pos, pos);
      input.dispatchEvent(new Event('input'));
      if (!isVimActive) {
        const wrap = input.parentElement;
        updateCursor(input, wrap);
      }
    } else if (code === 'Tab') {
      if (!isVimActive) {
        const sugg = input.parentElement.querySelector('.suggestion');
        if (sugg && sugg.textContent) {
          input.value += sugg.textContent;
          input.dispatchEvent(new Event('input'));
          sugg.textContent = '';
        } else {
          const before = input.value.slice(0, selStart);
          const after  = input.value.slice(selEnd);
          input.value = before + '    ' + after;
          const pos = before.length + 4;
          input.setSelectionRange(pos, pos);
          input.dispatchEvent(new Event('input'));
        }
        const wrap = input.parentElement;
        updateCursor(input, wrap);
      } else {
        // In vim, insert 4 spaces for tab
        const before = input.value.slice(0, selStart);
        const after = input.value.slice(selEnd);
        input.value = before + '    ' + after;
        const pos = before.length + 4;
        input.setSelectionRange(pos, pos);
        input.dispatchEvent(new Event('input'));
      }
    } else if (code === 'CapsLock') {
      // Block CapsLock via click-typing and show a transient tooltip
      showKeyTooltip(keyEl, 'Caps Lock cannot be activated via on-screen keyboard');
      updateCapsVisual(false);
    } else if (code.startsWith('Shift')) {
      keyEl.classList.add('pressed');
      setTimeout(() => keyEl.classList.remove('pressed'), 300);
      // no-op: Shift just modifies case of next char
    } else {
      let char = getCharForKey(keyEl);
      
      // Handle vim mode switching for on-screen keyboard
      if (isVimActive) {
        if (vimMode === 'NORMAL') {
          if (char === 'i') {
            setVimMode('INSERT');
            return; // Don't insert the 'i' character
          } else if (char === ':') {
            vimCommandBuffer = '';
            setVimMode('COMMAND');
            return; // Don't insert the ':' character
          } else if (char === 'a') {
            setVimMode('INSERT');
            // Move cursor to end of current position (handled above)
          } else if (char === 'o') {
            setVimMode('INSERT');
            // Add new line and go to insert mode
            const cursorPos = input.selectionStart;
            const lineEnd = input.value.indexOf('\n', cursorPos);
            const insertPos = lineEnd === -1 ? input.value.length : lineEnd;
            input.value = input.value.slice(0, insertPos) + '\n' + input.value.slice(insertPos);
            input.setSelectionRange(insertPos + 1, insertPos + 1);
            return;
          } else if (char === 'A') {
            setVimMode('INSERT');
            // Move to end of line
            const cursorPos = input.selectionStart;
            const lineEnd = input.value.indexOf('\n', cursorPos);
            const endPos = lineEnd === -1 ? input.value.length : lineEnd;
            input.setSelectionRange(endPos, endPos);
            return;
          } else if (char === 'O') {
            setVimMode('INSERT');
            // Add new line above and go to insert mode
            const cursorPos = input.selectionStart;
            const textBeforeCursor = input.value.substring(0, cursorPos);
            const lastNewline = textBeforeCursor.lastIndexOf('\n');
            const lineStart = lastNewline === -1 ? 0 : lastNewline + 1;
            input.value = input.value.slice(0, lineStart) + '\n' + input.value.slice(lineStart);
            input.setSelectionRange(lineStart + 1, lineStart + 1);
            return;
          } else if ('uxdyphjklgvwbe0$GnN/'.includes(char)) {
            // Show helpful message for common vim commands that aren't supported
            showVimMessage(`'${char}' not supported in this simplified vim - try :help for available commands`);
            return;
          }
        } else if (vimMode === 'COMMAND') {
          if (code === 'Enter') {
            executeVimCommand(vimCommandBuffer);
            vimCommandBuffer = '';
            setVimMode('NORMAL');
            return;
          } else if (code === 'Backspace') {
            if (vimCommandBuffer.length > 0) {
              vimCommandBuffer = vimCommandBuffer.slice(0, -1);
              setVimMode('COMMAND'); // Refresh display
            } else {
              setVimMode('NORMAL');
            }
            return;
          } else if (char && char.length === 1) {
            vimCommandBuffer += char;
            setVimMode('COMMAND'); // Refresh display
            return;
          }
        }
        
        // Handle ESC key for vim
        if (code === 'Escape') {
          if (vimMode === 'INSERT') {
            setVimMode('NORMAL');
          } else if (vimMode === 'COMMAND') {
            vimCommandBuffer = '';
            setVimMode('NORMAL');
          }
          return;
        }
        
        // Only insert text in INSERT mode
        if (vimMode !== 'INSERT') {
          return;
        }
      }
      
      const before = input.value.slice(0, selStart);
      const after  = input.value.slice(selEnd);
      input.value = before + char + after;
      const pos = before.length + char.length;
      input.setSelectionRange(pos, pos);
      input.dispatchEvent(new Event('input'));
      if (!isVimActive) {
        const wrap = input.parentElement;
        updateCursor(input, wrap);
      }
    }
  });
});

// Adjust output depending on shift/caps state
function getCharForKey(keyEl) {
  let char = keyEl.textContent.trim();
  const shift = document.querySelector('.key.shift-l.pressed, .key.shift-r.pressed');
  const caps = document.body.classList.contains('caps-on');

  if (/[a-z]/i.test(char)) {
    if (caps ^ !!shift) char = char.toUpperCase();
    else char = char.toLowerCase();
  } else if (shift && keyEl.dataset.alt) {
    char = keyEl.dataset.alt;
  }
  return char;
}

// Sync visual CapsLock state and body flag
function updateCapsVisual(isOn) {
  const capsKey = document.querySelector('.key[data-key="CapsLock"]');
  if (isOn) {
    document.body.classList.add('caps-on');
    if (capsKey) capsKey.classList.add('pressed');
  } else {
    document.body.classList.remove('caps-on');
    if (capsKey) capsKey.classList.remove('pressed');
  }
}

// Show a small transient tooltip above a key (wrapped with italic tip)
function showKeyTooltip(keyEl, message) {
  const tip = document.createElement('div');
  tip.innerHTML = `<div>${message}.</div><div style="font-style: italic; opacity: .9;"></div>`;
  tip.style.position = 'absolute';
  tip.style.bottom = '100%';
  tip.style.left = '50%';
  tip.style.transform = 'translate(-50%, -6px)';
  tip.style.background = '#333';
  tip.style.color = '#fff';
  tip.style.padding = '6px 8px';
  tip.style.borderRadius = '6px';
  tip.style.font = '600 11px/1.2 -apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif';
  tip.style.pointerEvents = 'none';
  tip.style.whiteSpace = 'normal';
  tip.style.textAlign = 'center';
  tip.style.boxShadow = '0 4px 10px rgba(0,0,0,.3)';
  tip.style.opacity = '0';
  tip.style.transition = 'opacity .15s ease, transform .15s ease';
  tip.style.display = 'inline-block';
  tip.style.boxSizing = 'border-box';
  tip.style.maxWidth = '56ch';
  tip.style.zIndex = '3000';
  keyEl.appendChild(tip);
  // animate in
  requestAnimationFrame(() => {
    tip.style.opacity = '1';
    tip.style.transform = 'translate(-50%, -10px)';
  });
  // remove after a short delay
  setTimeout(() => {
    tip.style.opacity = '0';
    tip.style.transform = 'translate(-50%, -6px)';
    setTimeout(() => tip.remove(), 200);
  }, 1800);
}

  </script>



<script>
//THIS IS FOR THE KEYBOARD

// Bring panel to front on interaction
document.addEventListener('DOMContentLoaded', () => {
  const panel = document.getElementById('keyboard-panel');
  if (panel) panel.addEventListener('mousedown', () => bringToFront(panel));
});

// Drag anywhere on the panel (header removed)
(function(){
  const panel  = document.getElementById('keyboard-panel');
  const handle = panel ? (panel.querySelector('.panel-header') || panel) : null;
  if (!panel) return;

  let dragging = false, offX = 0, offY = 0;

  handle.addEventListener('mousedown', e => {
    // Do not start drag during resize
    const cur = getComputedStyle(panel).cursor;
    if (/-resize$/.test(cur) || panel.dataset.resizing === '1') return;
    
    // Don't start drag if clicking on resize edges
    const r = panel.getBoundingClientRect();
    const x = e.clientX - r.left, y = e.clientY - r.top;
    const edge = 10;
    const onEdge = x < edge || y < edge || (r.width - x) < edge || (r.height - y) < edge;
    if (onEdge) return;
    
    dragging = true;
    offX = e.clientX - panel.offsetLeft;
    offY = e.clientY - panel.offsetTop;
    // if anchored to bottom, convert to top for free dragging
    panel.style.top = (panel.getBoundingClientRect().top + window.scrollY) + 'px';
    panel.style.bottom = 'auto';
    bringToFront(panel);
    document.body.style.userSelect = 'none';
  });

  document.addEventListener('mousemove', e => {
    if (!dragging) return;
    panel.style.left = (e.clientX - offX) + 'px';
    panel.style.top  = (e.clientY - offY) + 'px';
  });

  document.addEventListener('mouseup', () => {
    if (!dragging) return;
    dragging = false;
    document.body.style.userSelect = '';
  });
})();


</script>

  
  <!-- Floating button group -->
  <div class="floating-button-group">
    <!-- Theme toggle button -->
    <button class="floating-btn theme-toggle-btn" data-tip="Light Mode" aria-label="Toggle Theme">
      <svg class="moon-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
      <svg class="sun-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="12" cy="12" r="5" stroke="currentColor" stroke-width="2"/>
        <line x1="12" y1="1" x2="12" y2="3" stroke="currentColor" stroke-width="2"/>
        <line x1="12" y1="21" x2="12" y2="23" stroke="currentColor" stroke-width="2"/>
        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" stroke="currentColor" stroke-width="2"/>
        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" stroke="currentColor" stroke-width="2"/>
        <line x1="1" y1="12" x2="3" y2="12" stroke="currentColor" stroke-width="2"/>
        <line x1="21" y1="12" x2="23" y2="12" stroke="currentColor" stroke-width="2"/>
        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" stroke="currentColor" stroke-width="2"/>
        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" stroke="currentColor" stroke-width="2"/>
      </svg>
    </button>
    
    <!-- Terminal toggle button -->
    <button class="floating-btn terminal-toggle-btn" data-tip="Terminal" aria-label="Toggle Terminal">
      <svg width="18" height="12" viewBox="0 0 24 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M2 3l6 5-6 5" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
        <line x1="12" y1="13" x2="22" y2="13" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"/>
      </svg>
    </button>
    
    <!-- Cellular Automaton button -->
    <button class="floating-btn cellular-automaton-btn" data-tip="Cellular Automaton" aria-label="Cellular Automaton">
      <svg width="18" height="18" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
        <!-- Top row: 3 squares -->
        <rect x="2" y="2" width="4" height="4" fill="currentColor"/>
        <rect x="8" y="2" width="4" height="4" fill="currentColor"/>
        <rect x="14" y="2" width="4" height="4" fill="currentColor"/>
        
        <!-- Middle row: 2 squares -->
        <rect x="5" y="8" width="4" height="4" fill="currentColor"/>
        <rect x="11" y="8" width="4" height="4" fill="currentColor"/>
        
        <!-- Bottom row: 1 square -->
        <rect x="8" y="14" width="4" height="4" fill="currentColor"/>
      </svg>
    </button>
  </div>

  <!-- Scroll to top button -->
  <div class="scroll-to-top" id="scrollToTop">
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M12 8l-6 6h12l-6-6z" fill="currentColor"/>
    </svg>
  </div>

  <!-- Cellular Automaton Menu -->
  <div class="ca-menu" id="ca-menu">
    <div class="ca-menu-section">
      <div class="ca-menu-header">
        <span>Active <span class="ca-count" id="ca-count">(0)</span></span>
        <svg class="ca-info-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
          <path d="m9,9 l0,0 a3,3 0 1,1 6,0 c0,2 -3,3 -3,3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="m12,17 l.01,0" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>
      <div id="active-automatons">
        <div class="ca-menu-item">None</div>
      </div>
      <div class="ca-menu-item deactivate-all disabled" onclick="deactivateAllAutomatons()">
        Deactivate All
      </div>
    </div>
    
    <div class="ca-menu-section">
      <div class="ca-menu-header">
        <span>Launch</span>
      </div>
      <div class="ca-menu-item launch-item" draggable="true" data-automaton-type="worm">Worm</div>
      <div class="ca-menu-item launch-item" draggable="true" data-automaton-type="flower">Flower</div>
      <div class="ca-menu-item launch-item" draggable="true" data-automaton-type="moss">Moss</div>
    </div>
  </div>

  <!-- Info Modal -->
  <div class="ca-info-modal" id="ca-info-modal">
    <div class="ca-info-modal-header" id="ca-modal-header">
      <div class="ca-info-modal-title">
        Cellular Automata Information
        <span class="drag-hint">Click here to drag</span>
      </div>
      <button class="ca-info-modal-close" onclick="hideCAInfo()">×</button>
    </div>
    <div class="ca-info-modal-content">
      <p>A <strong>cellular automaton</strong> is a mathematical model consisting of a grid of cells, each in one of a finite number of states. The grid evolves through discrete time steps according to a set of rules based on the states of neighboring cells.</p>
      
      <p>Learn more at <a href="https://en.wikipedia.org/wiki/Cellular_automaton" target="_blank">Wikipedia - Cellular Automaton</a>.</p>
      
      <h3>Available Automata</h3>
      
      <div class="ca-automaton-grid">
        <div class="ca-automaton-card">
          <h4>Worm</h4>
          <p>An organic, snake-like creature that moves smoothly across the screen with natural curving behavior and enhanced directional changes.</p>
        </div>
        
        <div class="ca-automaton-card">
          <h4>Flower</h4>
          <p>A blooming pattern that cycles through three distinct growth types: circular, petal, and spiral formations with dynamic sizing and colors.</p>
        </div>
        
        <div class="ca-automaton-card">
          <h4>Moss</h4>
          <p>A viral spreading pattern that grows outward from initial points, creating connected colonies with enhanced connectivity algorithms.</p>
        </div>
      </div>
      
      <h3>Usage Instructions</h3>
      <p><strong>Launching (Method 1):</strong> Click on any automaton name in the "Launch" section to spawn a new instance at a random location.</p>
      <p><strong>Launching (Method 2):</strong> Drag and drop any automaton type from the "Launch" section to spawn it at your desired location on the screen. Watch for the blue seed indicator while dragging!</p>
      <p><strong>Identification:</strong> Hover over any automaton pixels on the screen to see a tooltip identifying which automaton it belongs to.</p>
      <p><strong>Selection & Highlighting:</strong> Click on an active automaton name in the "Active" section to permanently highlight it with a green glow. Click another to switch selection.</p>
      <p><strong>Hover Preview:</strong> Hover over automaton names in the menu to temporarily flash them on screen for easy identification.</p>
      <p><strong>Renaming:</strong> Click the pencil icon (✏️) next to any active automaton to give it a custom name.</p>
      <p><strong>Deactivating:</strong> Click the red "×" button next to any active automaton to make it disintegrate, or use "Deactivate All" to remove all active automata.</p>
      <p><strong>Multiple Instances:</strong> You can run multiple instances of the same type (e.g., Worm 1, Worm 2, etc.). Each can be independently named, selected, and controlled.</p>
      <p><strong>Active Count:</strong> The number in parentheses next to "Active" shows how many automata are currently running.</p>
    </div>
  </div>

  <!-- Rename Modal -->
  <div class="ca-rename-modal" id="ca-rename-modal">
    <div class="ca-rename-modal-header">Rename Automaton</div>
    <input type="text" class="ca-rename-modal-input" id="ca-rename-input" placeholder="Enter new name...">
    <div class="ca-rename-modal-buttons">
      <button class="ca-rename-modal-btn cancel" onclick="hideRenameModal()">Cancel</button>
      <button class="ca-rename-modal-btn save" onclick="saveRename()">Save</button>
    </div>
  </div>

<script>
// Scroll to top functionality
document.addEventListener('DOMContentLoaded', () => {
  const scrollToTopBtn = document.getElementById('scrollToTop');
  const websiteMenu = document.querySelector('.website-menu');
  
  // Show/hide scroll button based on menu visibility
  function toggleScrollButton() {
    const menuRect = websiteMenu.getBoundingClientRect();
    const isMenuVisible = menuRect.bottom > 0;
    
    if (isMenuVisible) {
      scrollToTopBtn.style.display = 'none';
    } else {
      scrollToTopBtn.style.display = 'flex';
    }
  }
  
  // Scroll to top when button is clicked
  scrollToTopBtn.addEventListener('click', () => {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  });
  
  // Monitor scroll position
  window.addEventListener('scroll', toggleScrollButton);
  
  // Initial check
  toggleScrollButton();
});
</script>

</body>
</html>
